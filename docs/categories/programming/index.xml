<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on tlehman@home</title>
    <link>/categories/programming/index.xml</link>
    <description>Recent content in Programming on tlehman@home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Making a Go Game for the Web</title>
      <link>/blog/2015/11/03/making-a-go-game-for-the-web/</link>
      <pubDate>Tue, 03 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/2015/11/03/making-a-go-game-for-the-web/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been feeling productive in the last few weeks. I just finished two Coursera classes, one in machine learning and one in Swift programming. I also finished my minimum viable go game: &lt;a href=&#34;http://goga.me&#34;&gt;goga.me&lt;/a&gt;. And we are working on a really exciting feature at work. I really like having lots of interesting things to work on. Anyway, enough feelings, you came here for games and code.&lt;/p&gt;

&lt;p&gt;The game of Go is ancient, it has very few rules, but an unfathomable level of complexity emerges from all the possible ways the pieces can be put on the board. The graphics were very straightforward to implement, it&amp;rsquo;s just a square grid with some colored circles, I don&amp;rsquo;t usually work with graphics, so I experimented with some different web technologies to see what worked best.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blogimg/gogame_screenshot_0.png&#34; alt=&#34;example go game&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;attempt-1-html5-canvas&#34;&gt;Attempt 1, HTML5 Canvas&lt;/h2&gt;

&lt;p&gt;About a year ago I wrote a Go board using the HTML5 &amp;lt;canvas&amp;gt; element, &lt;a href=&#34;https://github.com/tlehman/go-websocket/blob/master/go_game.js&#34;&gt;here&amp;rsquo;s the source code&lt;/a&gt;, it doesn&amp;rsquo;t actually have a server side, I decided to ditch that approach, since canvas is really great for making arbitrarily complicated bitmap graphics, but I needed something much simpler. Also, when zooming in on a phone, the click event location was not the same as the location where the code drew a new piece.&lt;/p&gt;

&lt;h2 id=&#34;attempt-2-svg&#34;&gt;Attempt 2, SVG&lt;/h2&gt;

&lt;p&gt;After almost a year I came back to the project, I wrote out a rails backend for the data storage and game logic, and then learned SVG (Scalable Vector Graphics). Here&amp;rsquo;s &lt;a href=&#34;https://github.com/tlehman/goga.me/blob/b585f4dec45d726615d73fca301c261d2df17167/app/views/matches/show.html.erb&#34;&gt;the source code&lt;/a&gt;, what I like about SVG is that I can make the board positions part of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Document_Object_Model&#34;&gt;DOM&lt;/a&gt; and bind javascript events to the positions. This solves a problem with zooming, so that when I zoom in on a phone, the click event shows up in the right position.&lt;/p&gt;

&lt;h2 id=&#34;websockets-enabling-live-back-and-forth-gameplay&#34;&gt;WebSockets, enabling live back and forth gameplay&lt;/h2&gt;

&lt;p&gt;Another exciting technology that I spent some time learning about was &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&#34;&gt;WebSockets&lt;/a&gt;, this allows two players to open a direct connection to one another, so that as soon as someone plays a piece, the other one knows. This way, the user does not have to refresh, it&amp;rsquo;s all live. I used the websockets-rails library to handle setting up a user-to-user connection through the rails backend. The &lt;a href=&#34;https://github.com/tlehman/goga.me/blob/master/app/views/matches/show.html.erb#L67-L80&#34;&gt;source code to handle binding and triggering is here&lt;/a&gt;. To see it in action, &lt;a href=&#34;http://goga.me/users/sign_up&#34;&gt;make an account at goga.me&lt;/a&gt;, and then &lt;a href=&#34;http://goga.me/matches/new&#34;&gt;create a match&lt;/a&gt;, and click &amp;lsquo;Start Match&amp;rsquo;, that will start a match against yourself, you can open it up on multiple devices, and when you start playing, the other screen will immediately update, it&amp;rsquo;s pretty cool!&lt;/p&gt;

&lt;h2 id=&#34;other-challenges&#34;&gt;Other challenges&lt;/h2&gt;

&lt;p&gt;After getting the graphics and networking to work correctly, the only other major challenge was handling capturing. Capturing is where one color completely surrounds the other color, and the surrounded pieces get removed, you can see it in the following screen capture:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blogimg/gogame_capturing.gif&#34; alt=&#34;example capturing in a go game&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The challenge is to determine the parts of the board that are connected. Since each piece can only be connected to it&amp;rsquo;s four neighboring pieces of the same color, you can start finding connected components by picking a point and walking to every piece connected to it that is the same color. A prime choice for this problem is a breadth first search:&lt;/p&gt;

&lt;h2 id=&#34;breadth-first-search&#34;&gt;Breadth First Search&lt;/h2&gt;

&lt;p&gt;To wrap my head around this algorithm I had to get out my trusty graph theory book. Here&amp;rsquo;s a summary of the algorithm and an example:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Input&lt;/strong&gt;: An unweighted graph and a start vertex u&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Idea&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maintain a set R of vertices that have been reached but not searched and&lt;/li&gt;
&lt;li&gt;a set S of vertices that have been searched.&lt;/li&gt;
&lt;li&gt;The set R is maintained as a First-In First-Out list (&lt;a href=&#34;https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29&#34;&gt;queue&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Initialization&lt;/strong&gt;: R = {u}, S = ø, d(u,u) = 0&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Iteration&lt;/strong&gt;: As long as R &amp;neq; ø, we search from the first vertex v of R. The neighbors of v not in (S U R) are added to the back of R and then v is removed from the front of R and placed in S.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Let G be the adjacency graph of the following Go shape:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   1  2  3  4  5  6
 1    .  o  o  o  .
 2    .  .  .  .  .  &amp;lt;--- black component
 3    .
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;v&lt;/th&gt;
&lt;th&gt;R&lt;/th&gt;
&lt;th&gt;S&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(2,1)&lt;/td&gt;
&lt;td&gt;[(2,1)]&lt;/td&gt;
&lt;td&gt;{}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(2,1)&lt;/td&gt;
&lt;td&gt;[(2,2)]&lt;/td&gt;
&lt;td&gt;{(2,1)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(2,2)&lt;/td&gt;
&lt;td&gt;[(2,3),(3,2)]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(2,3)&lt;/td&gt;
&lt;td&gt;[(3,2)]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2),(2,3)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(3,2)&lt;/td&gt;
&lt;td&gt;[(4,2)]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2),(2,3),(3,2)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(4,2)&lt;/td&gt;
&lt;td&gt;[(5,2)]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2),(2,3),(3,2),(4,2)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(5,2)&lt;/td&gt;
&lt;td&gt;[(6,2)]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2),(2,3),(3,2),(4,2),(5,2)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(6,2)&lt;/td&gt;
&lt;td&gt;[(6,1)]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2),(2,3),(3,2),(4,2),(5,2),(6,2)}&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(6,1)&lt;/td&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;{(2,1),(2,2),(2,3),(3,2),(4,2),(5,2),(6,2),(6,1)}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br&gt; &lt;br&gt;&lt;/p&gt;

&lt;p&gt;Once I worked through the steps with this example and several others, writing the code to implement it was very straightforward, here&amp;rsquo;s the &lt;a href=&#34;https://github.com/tlehman/go-websocket/blob/8094890048ca845c0fef416573b8aba533ca6ea9/jasmine/src/ComponentMap.js#L16-L51&#34;&gt;javascript version&lt;/a&gt; and the &lt;a href=&#34;https://github.com/tlehman/goga.me/blob/b585f4dec45d726615d73fca301c261d2df17167/app/presenters/board_presenter.rb#L24-L41&#34;&gt;ruby version&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My go game is at a good stopping point for now, I still need to fix a few edge cases and add a chat feature. Also, I realized how satisfying it is to take a bunch of stuff I learned and make something real with it. I plan on making a native mobile client to this (iOS and Android), but that will take some more time and work.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Word frequencies after removing common words</title>
      <link>/blog/2015/02/10/word-frequencies-after-removing-common-words/</link>
      <pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/2015/02/10/word-frequencies-after-removing-common-words/</guid>
      <description>

&lt;p&gt;In taking the &lt;a href=&#34;https://class.coursera.org/mmds-002&#34;&gt;Coursera class on Mining Massive Datasets&lt;/a&gt;, the problem of computing word frequency for very large documents came up. I wanted some convenient tools for breaking documents into streams of words, and also a tool to remove common words like &amp;lsquo;the&amp;rsquo;, so I wrote up &lt;code&gt;words&lt;/code&gt; and &lt;code&gt;decommonize&lt;/code&gt;. The &lt;code&gt;decommonize&lt;/code&gt; script is just a big &lt;code&gt;grep -v &#39;(foo|bar|baz)&#39;&lt;/code&gt;, where the words foo, bar and baz come from the words in a file. I made a script &lt;code&gt;generate_decommonize&lt;/code&gt; that reads in a list of common words, and builds the regex for &lt;code&gt;grep -v&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;example-usage-of-words-and-decommonize&#34;&gt;Example usage of &lt;code&gt;words&lt;/code&gt; and &lt;code&gt;decommonize&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;The full source code is available &lt;a href=&#34;https://github.com/tlehman/words&#34;&gt;here on github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After running &lt;code&gt;make install&lt;/code&gt;, you should have &lt;code&gt;words&lt;/code&gt; and &lt;code&gt;decommonize&lt;/code&gt; in your PATH, you can use them to find key words that are characteristic of a document, I chose&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the U.S. Declaration of Independence:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
$ words &lt; declaration_of_independence.txt | decommonize  | sort | uniq -c | sort -n | tail
   4 time
   5 among
   5 most
   5 powers
   6 government
   6 such
   7 right
   8 states
   9 laws
  10 people
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Sherlock Holmes&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
$ words &lt; doyle_sherlock_holmes.txt | decommonize  | sort | uniq -c | sort -n | tail
 174 think
 175 more
 177 over
 212 may
 212 should
 269 little
 274 mr
 288 man
 463 holmes
 466 upon
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Working with Unix Processes (by @jstorimer)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
$ words &lt; working_with_unix_processes.txt | decommonize  | sort | uniq -c | sort -n | tail
  73 signal
  82 system
  88 ruby
  90 exit
 100 code
 100 parent
 143 its
 146 child
 184 processes
 444 process
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;words&lt;/code&gt; breaks up the document into lower-case alphabetic words, then &lt;code&gt;decommonize&lt;/code&gt; greps out the common words, and &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;uniq -c&lt;/code&gt; are used to count instances of each decommonized word, and then the results are sorted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tip calculation using Bison grammar</title>
      <link>/blog/2015/01/22/tip-calculation-using-bison-grammar/</link>
      <pubDate>Thu, 22 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/2015/01/22/tip-calculation-using-bison-grammar/</guid>
      <description>&lt;p&gt;As long as I&amp;rsquo;ve been able to do arithmetic, I&amp;rsquo;ve been able to figure out calculating taxes and tips, it&amp;rsquo;s easy. Given a
dollar value $17.91 we can figure out the total with a tip of 18% as $17.91*(1.18) = $21.14&lt;/p&gt;

&lt;p&gt;However, it would be nice just to enter in &lt;code&gt;$17.91 + 18%&lt;/code&gt; and have the computer figure it out. So one time at lunch after
calculating the tip for a burrito I decided to learn lex and bison, which can be used together to create a mini language.&lt;/p&gt;

&lt;p&gt;The grammar I used was the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start:
    dollars OP_PLUS percentage
    |
    dollars OP_MINUS percentage

dollars:
    TOKDOLLAR NUMBER

percentage:
    NUMBER TOKPERCENT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;OP_PLUS&lt;/code&gt; and &lt;code&gt;OP_MINUS&lt;/code&gt; come from &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;. Also, &lt;code&gt;TOKDOLLAR&lt;/code&gt; and &lt;code&gt;TOKPERCENT&lt;/code&gt; are &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then, below each grammar rule, I added some C code that would be generated if the input matches that rule:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start:
    dollars OP_PLUS percentage
    {
        double dollars = $1;
        double percentage = ($3)/(100.0);
        double total = dollars + dollars*percentage;
        printf(&amp;quot;$%.2f&amp;quot;, total);
    }
    |
    dollars OP_MINUS percentage
    {
        double dollars = $1;
        double percentage = ($3)/(100.0);
        double total = dollars - dollars*percentage;
        printf(&amp;quot;$%.2f&amp;quot;, total);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full source code is available &lt;a href=&#34;https://github.com/tlehman/tipcalc&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now, it is true that this is no more powerful than a regular expression, however,
I intend on modifying it to allow nested expressions like &lt;code&gt;(($2 + 4%) + 4%)&lt;/code&gt;, which
would be useful for compound interest calculations. That would be more powerful than
regular expressions, meaning it would be at least a &lt;a href=&#34;https://en.wikipedia.org/wiki/Context-free_grammar&#34;&gt;context-free grammar&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Update: &lt;a href=&#34;/blog/2015/01/27/parsing-nested-expressions-using-bison&#34;&gt;In the future, I wrote about implementing this&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Counting bits in integers</title>
      <link>/blog/2014/02/08/counting-bits-in-integers/</link>
      <pubDate>Sat, 08 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/02/08/counting-bits-in-integers/</guid>
      <description>&lt;p&gt;While working on the code to count the number of fifteens I had in a hand in cribbage, I found it would be useful to count the number of bits in an integer. The comment below explains why it is useful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;    // Fifteens
    //     A Fifteen is any combination of cards whose ranks sum up to 15.
    //
    //     To find fifteens, we need to look at all combinations of cards.
    //     For example, for a hand of three cards:  5♣  10♥  5♥  we must
    //     consider all 2^3 - 1 = 7 non-empty subsets:
    //        Hand         | Bits | Sum
    //        -------------|------|-----
    //                 5♥  | 001  |  (5)
    //            10♥      | 010  | (10)
    //            10♥  5♥  | 011  | (15)  *
    //        5♣           | 100  |  (5)
    //        5♣       5♥  | 101  | (10)
    //        5♣  10♥      | 110  | (15)  *
    //        5♣  10♥  5♥  | 111  | (20)
    //
    //     There is a well known correspondence betweeen subsets and binary
    //     representations of integers, illustrated in the &#39;Bits&#39; column above.
    //     The number of bits that are equal to 1 is the cardinality of the 
    //     corresponding subset.
    //     Using this correspondence, we can enumerate all 2^n subsets by looping
    //     an integer from 0 to (2^n - 1) and identifying the bits that are one
    //     with the subset membership relation.
    //
    Card* subset[count];
    for(i = 0; i &amp;lt; 2_TO_THE(count); ++i) {
        zero_cards(subset);

        // get bits of i
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since subsets and the bit representations of integers are in one-to-one correspondence, I can enumerate all subsets of an n-set by simply counting from 0 to 2&lt;sup&gt;n&lt;/sup&gt;-1, then I can use the bits in the loop variable to determine which element of the set is in the subset. From the example in the comment above, you can see that the bits of the row number line up with the elements in the subsets.&lt;/p&gt;

&lt;p&gt;In order to finish this code, I wanted a way to count the number of bits in an integer. I looked around for an existing algorithm to do it, and I found this, from K&amp;amp;R:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned int v; // count the number of bits set in v
unsigned int c; // c accumulates the total bits set in v
for (c = 0; v; c++) {
    v &amp;amp;= v - 1; // clear the least significant bit set
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had no idea how it worked, so I tried to figure it out. The parts that I do understand are the roles of v and c, the former is the number for which we are counting bits, and the latter is the actual number of bits.&lt;/p&gt;

&lt;p&gt;Why does &lt;code&gt;v &amp;amp; (v-1)&lt;/code&gt; clear the least significant bit?&lt;/p&gt;

&lt;p&gt;To figure this out, I considered a general n-bit integer, represented in base 2, I thought about it as&lt;/p&gt;

&lt;p&gt;{% latex %}
$ v = v_1v_2&amp;hellip;v_n $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;If v is odd, then v&lt;sub&gt;n&lt;/sub&gt; = 1, so v-1 simply clears the least significant bit, and since the first n-1 bits are the same, the bitwise AND of v and v-1 is just v-1, which v with the least significant bit set to zero (cleared).&lt;/p&gt;

&lt;p&gt;Otherwise, v is even, which means v&lt;sub&gt;n&lt;/sub&gt; = 0. What is v-1 in this case?&lt;/p&gt;

&lt;p&gt;If v = 32 = 100000&lt;sub&gt;2&lt;/sub&gt; (base 2), then v-1 = 011111&lt;sub&gt;2&lt;/sub&gt;, so v&amp;amp;v-1 = 000000&lt;sub&gt;2&lt;/sub&gt;, which is v with it&amp;rsquo;s least significant bit set to zero.&lt;/p&gt;

&lt;p&gt;So far, so good, but that is only one example, we need to prove it for a general even n-bit integer, not just 32.&lt;/p&gt;

&lt;p&gt;Let v be an n-bit even integer, and v&lt;sub&gt;k&lt;/sub&gt;=1 is the least significant bit. Then v&lt;sub&gt;n&lt;/sub&gt;=0, and k &amp;lt; n.&lt;/p&gt;

&lt;p&gt;We can then write v in the following way:&lt;/p&gt;

&lt;p&gt;{% latex %}&lt;/p&gt;

&lt;p&gt;\begin{align}
  v &amp;amp;= v_1v_2v_3&amp;hellip;v&lt;em&gt;kv&lt;/em&gt;{k+1}&amp;hellip;v_n
\  &amp;amp;= v_1v_2v_3&amp;hellip;10&amp;hellip;0
\end{align}&lt;/p&gt;

&lt;p&gt;{% endlatex %}&lt;/p&gt;

&lt;p&gt;Then, the number v&lt;sub&gt;k&lt;/sub&gt;v&lt;sub&gt;k-1&lt;/sub&gt;&amp;hellip;v&lt;sub&gt;n&lt;/sub&gt; = 2&lt;sup&gt;n-k&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;We can find v-1 by considering the subproblem of v&lt;sub&gt;k&lt;/sub&gt;v&lt;sub&gt;k+1&lt;/sub&gt;&amp;hellip;v&lt;sub&gt;n&lt;/sub&gt; - 1 = 2&lt;sup&gt;n-k&lt;/sup&gt;-1.&lt;/p&gt;

&lt;p&gt;{% latex %}&lt;/p&gt;

&lt;p&gt;\begin{align}
    &amp;amp;v&lt;em&gt;k &amp;amp;v&lt;/em&gt;{k+1} &amp;amp;v&lt;em&gt;{k+1} &amp;amp;&amp;hellip; &amp;amp;v&lt;/em&gt;{n-1} &amp;amp;v_n &amp;amp;- 1
\  &amp;amp;1   &amp;amp;0       &amp;amp;0       &amp;amp;&amp;hellip; &amp;amp;0       &amp;amp;0   &amp;amp;- 1
\ =  &amp;amp;0   &amp;amp;1       &amp;amp;1       &amp;amp;&amp;hellip; &amp;amp;1       &amp;amp;1
\end{align}&lt;/p&gt;

&lt;p&gt;{% endlatex %}&lt;/p&gt;

&lt;p&gt;Now, we can see that v and v-1 have the same first k-1 bits, with the last n-k+1 bits opposite, so that the bitwise AND clears the last n-k+1 bits. Since v has the last n-k bits equal to 0 and the k-th bit equal to one, it follows that v&amp;amp;(v-1) clears the least significant bit. This completes the proof.&lt;/p&gt;

&lt;p&gt;Now, looking at the code again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;unsigned int v; // count the number of bits set in v
unsigned int c; // c accumulates the total bits set in v
for (c = 0; v; c++) {
    v &amp;amp;= v - 1; // clear the least significant bit set
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will clear the least significant bit, increment c, then if v is nonzero, repeat. Now this makes sense.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrapping most of a C dev environment</title>
      <link>/blog/2013/11/25/bootstrapping-most-of-a-c-dev-environment/</link>
      <pubDate>Mon, 25 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/11/25/bootstrapping-most-of-a-c-dev-environment/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve taken a break from SICP and TAOCP in order to get a good foundation in the &lt;a href=&#34;http://c2.com/cgi/wiki?CeeLanguage&#34;&gt;C programming language&lt;/a&gt;, I&amp;rsquo;m familiar with it, but that is not good enough. The reason is because C exposes a lot more about how the computer works, understanding it is an important first step in understanding computers. Steve Yegge said it well:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You just have to know C. Why? Because for all practical purposes, every computer in the world you&amp;rsquo;ll ever use is a von Neumann machine, and C is a lightweight, expressive syntax for the von Neumann machine&amp;rsquo;s capabilities.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The SICP world-view is from a parallel world of computing that grew from John McCarthy&amp;rsquo;s LISP. There were even alternatives to the von Neumann architecture (Lisp Machines) that were built, which natively ran Lisp.&lt;/p&gt;

&lt;p&gt;In the interest of &lt;a href=&#34;http://c2.com/cgi/wiki?ToGrok&#34;&gt;grokking&lt;/a&gt; computers (not just knowing how to put them together, configure and run scripts on them), I should really know C.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve started with the basic command line tools:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grep(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wc(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: &lt;code&gt;foo(n)&lt;/code&gt; means that the command &lt;code&gt;foo&lt;/code&gt; is on manpage section &lt;code&gt;n&lt;/code&gt;, to view the manpage, type &lt;code&gt;man n foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;cat(1)&lt;/code&gt;, it was a simple matter of using &lt;code&gt;read(2)&lt;/code&gt; and &lt;code&gt;write(2)&lt;/code&gt;, the only tricky thing is getting familiar with IO buffering, but other than that it&amp;rsquo;s trivial. After having written these tools, I&amp;rsquo;ve been using them to work on this code, so I would use my own &lt;code&gt;cat&lt;/code&gt; and my own &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;wc&lt;/code&gt; inspect the code I had just written, it was very rewarding.&lt;/p&gt;

&lt;p&gt;From there I decided I should go further and write an editor, I researched to find the simplest editor that was common on Unix-like systems. I didn&amp;rsquo;t have to look far to find &lt;a href=&#34;http://c2.com/cgi/wiki?EdIsTheStandardTextEditor&#34;&gt;ed&lt;/a&gt;, it is a line-based editor, and after spending 30 minutes learning how to use it, I found the commands similar vi or vim, except that I had to imagine the text, I couldn&amp;rsquo;t see it as I typed. Then I&amp;rsquo;ll need a shell, then a C compiler, then an operating system.&lt;/p&gt;

&lt;p&gt;I can probably handle a shell, but I&amp;rsquo;ll need to study a lot more before I put together a compiler and operating system.&lt;/p&gt;

&lt;p&gt;My long term goal is to be able to write a whole develpment environment from scratch. Since Unix-like systems are built from small pieces, it makes it reasonably feasible to do it piece by piece.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fixed point in ruby hash function</title>
      <link>/blog/2013/04/30/fixed-point-in-ruby-hash-function/</link>
      <pubDate>Tue, 30 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/04/30/fixed-point-in-ruby-hash-function/</guid>
      <description>&lt;p&gt;A fixed point of a function  \( f:S \to S \) is an element \(x \in
S\) such that&lt;/p&gt;

&lt;p&gt;{% latex %}
$ f(x) = x $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;That is, \(f\) is a no-op on \(x\). Some examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The identity function on any set has all points as fixed points&lt;/li&gt;
&lt;li&gt;The absolute value function has any positive real number as a fixed
point&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://fmota.eu/blog/base64-fixed-point.html&#34;&gt;base64 encoding function has a string as a fixed point&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Check out that link above, fmota wrote about how they discovered a
fixed point in the base64 encoding function, it&amp;rsquo;s very interesting)&lt;/p&gt;

&lt;p&gt;Ruby&amp;rsquo;s &lt;code&gt;Fixnum&lt;/code&gt; class has an instance method called &lt;code&gt;hash&lt;/code&gt;. It is the
&lt;a href=&#34;http://en.wikipedia.org/wiki/Hash_function#Hash_tables&#34;&gt;hash function&lt;/a&gt;
used by the &lt;code&gt;Hash&lt;/code&gt; class to locate the value.&lt;/p&gt;

&lt;p&gt;One thing to note that is interesting,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;42.class == 42.hash.class # true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The integer literal &lt;code&gt;42&lt;/code&gt; is an instance of Ruby&amp;rsquo;s &lt;code&gt;Fixnum&lt;/code&gt; class,
which is exactly the type that is returned by &lt;code&gt;Fixnum#hash&lt;/code&gt;. So, if we
let &lt;code&gt;N&lt;/code&gt; be the set of all &lt;code&gt;Fixnum&lt;/code&gt; values, and &lt;code&gt;h&lt;/code&gt; be the hash function,
then the function&lt;/p&gt;

&lt;p&gt;{% latex %}
$h: N \to N $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;Does &lt;code&gt;h&lt;/code&gt; have a fixed point? Let&amp;rsquo;s find out, the generic way to find a
fixed point is to apply the function over and over and see if any of
the iterates are the same:&lt;/p&gt;

&lt;p&gt;{% latex %}
$ x, f(x), f(f(x)), f(f(f(x))), f(f(f(f(x)))), &amp;hellip; $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;In Ruby, we could start with a value &lt;code&gt;n&lt;/code&gt; and loop until the next step
is the same as the current step:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;
def find_fixed_point(n)
  m = n.hash

  while n != m
    puts n

    n = m
    m = m.hash
  end

  puts n
  puts m
end

find_fixed_point(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code terminates in 62 steps, here is the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;42
1818615832163790001
97302458964831319
3241638738618469355
-1538644867632915805
4556542729113842835
-707745146237515789
4042604241838953267
-3938749251519753037
-3262109345615183437
2726245977638182835
2363300705344768947
-1077013243652537421
3673817879955862451
4480325791167763379
-3402798086540651597
4108231692027892659
742946247983240115
3380480562708485043
-3611524319884209229
2461606551736423347
2556374051055866803
-853528980180560973
301437974151041971
-684460774007630925
2785951334519935923
1234765569947210675
3485015807817552819
-2988541774381313101
-2969442663896050765
3743208565546292147
-2143850698816220237
985968426639299507
-2191943438346873933
465213455999570867
-1249312491853966413
-1963857645314632781
3582438201892410291
146054934450017203
-2298892513473850445
-813726632499604557
-1775501339152477261
-4287223502620716109
-2436529928794664013
-3361799749893745741
487423333182608307
4144170308747006899
1852752892089734067
1009031649399542707
-1504821367603326029
-1663010304514714701
1979275894121173939
657469403487933363
-3805597827236228173
-608042091803176013
3625341557925090227
-4337022583265946701
4381946295323333555
-3544389048848739405
-4409080177303874637
3084909602640630707
1931988098033783731
-373854911179910221
4237831107247477683
4237831107247477683
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the integer &lt;code&gt;4237831107247477683&lt;/code&gt; is a fixed point of
&lt;code&gt;Fixnum#hash&lt;/code&gt;, that means that in the implementation of &lt;code&gt;Hash&lt;/code&gt;, the
value &lt;code&gt;4237831107247477683&lt;/code&gt; would have itself as a key.&lt;/p&gt;

&lt;p&gt;There are more examples (play with the code yourself!), and I would
like to look deeper into why this hash function has a fixed point.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualization of SICP Exercise 1.14</title>
      <link>/blog/2013/04/07/visualization-of-sicp-exercise-1-dot-14/</link>
      <pubDate>Sun, 07 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/04/07/visualization-of-sicp-exercise-1-dot-14/</guid>
      <description>

&lt;p&gt;I am currently working my way the &lt;a href=&#34;https://github.com/tlehman/sicp-exercises#readme&#34;&gt;Structure and Interpretation of
Computer Programs&lt;/a&gt;
and I&amp;rsquo;ve skipped past exercise 1.14, and come back to it after a bit
of thinking, here&amp;rsquo;s the problem, and then the exercise.&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;How many ways are there to make change of a given amount &lt;code&gt;a&lt;/code&gt; with the
following kinds of coins?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pennies&lt;/li&gt;
&lt;li&gt;nickels&lt;/li&gt;
&lt;li&gt;dimes&lt;/li&gt;
&lt;li&gt;quarters&lt;/li&gt;
&lt;li&gt;half-dollars&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a recursive solution to this combinatorial problem, which can
readily be made into executable code in Scheme, this kind of solution
is very standard in enumerative combinatorics:&lt;/p&gt;

&lt;p&gt;The number of ways to change amount &lt;code&gt;a&lt;/code&gt; using &lt;code&gt;n&lt;/code&gt; kinds of coins
equals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the number of ways to change amount &lt;code&gt;a&lt;/code&gt; using all but the first
kind of coin, plus&lt;/li&gt;
&lt;li&gt;the number of ways to change amount &lt;code&gt;a - d&lt;/code&gt; using all &lt;code&gt;n&lt;/code&gt; kinds of
coins, where &lt;code&gt;d&lt;/code&gt; is the denomination of the first kind of coin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that those two items are mutually exclusive and exhaustive
conditions, so the result can be calculated by simply adding the two
values.&lt;/p&gt;

&lt;p&gt;In scheme, the above list could be transliterated as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;	(+ (cc a (- n 1))
	   (cc (- a d) n))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;(cc a n)&lt;/code&gt; computes the number of ways of changing amount &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt;
kinds of coins.&lt;/p&gt;

&lt;p&gt;The full code for the &lt;code&gt;count-change&lt;/code&gt; procedure can be found
&lt;a href=&#34;https://github.com/tlehman/sicp-exercises/blob/master/count-change.scm#L3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-exercise&#34;&gt;The Exercise&lt;/h2&gt;

&lt;p&gt;With the &lt;code&gt;count-change&lt;/code&gt; procedure at hand, Exercise 1.14 is to &amp;ldquo;draw
the tree illustrating the process generated by the &lt;code&gt;count-change&lt;/code&gt;
procedure in making change for 11 cents.&amp;rdquo;&lt;/p&gt;

&lt;h2 id=&#34;the-solution&#34;&gt;The Solution&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;count-change&lt;/code&gt; procedure uses the &lt;code&gt;(cc a n)&lt;/code&gt; procedure where
&lt;code&gt;n = 5&lt;/code&gt;, and the &lt;code&gt;cc&lt;/code&gt; procedure naturally gives rise to a binary
tree that locally looks like this:&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/ccan.png %}&lt;/p&gt;

&lt;p&gt;I prefer to make the computer go through all the steps and produce an
image for me, so I took a break on 1.14 and thought about it for a
while.&lt;/p&gt;

&lt;p&gt;To represent the tree, I used the graph-description language
&lt;a href=&#34;http://www.graphviz.org/pub/scm/graphviz2/doc/info/lang.html&#34;&gt;DOT&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To generate the tree, I started by adding a print statement around the
recursion steps, the problem with that is that there can be distinct
nodes that happen to have the same argument values, that is, the node
in the tree may be labeled &lt;code&gt;(cc a n)&lt;/code&gt;, but there may also be multiple
nodes with the same &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; values. To avoid this, each node must
be given a unique id, and then be displayed with the &lt;code&gt;(cc a n)&lt;/code&gt; label.&lt;/p&gt;

&lt;p&gt;One way to label a binary tree&amp;rsquo;s nodes is to make the id be a map of
the location of the node in the tree. For example, if a node of the
tree has id &lt;code&gt;x&lt;/code&gt;, then the root&amp;rsquo;s children will be &lt;code&gt;xl&lt;/code&gt; and &lt;code&gt;xr&lt;/code&gt;,
respectively, where &lt;code&gt;l&lt;/code&gt; stands for &amp;lsquo;left&amp;rsquo; and &lt;code&gt;r&lt;/code&gt; stands for &amp;lsquo;right&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;If the root&amp;rsquo;s id is &lt;code&gt;s&lt;/code&gt;, then a typical node would be labeled
something like &lt;code&gt;sllrrl&lt;/code&gt;. Starting at the root, you can find the node
by going left two times, right two times, and then left.&lt;/p&gt;

&lt;p&gt;Here is the full source of the tree-generating code &lt;code&gt;cc-graph&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;quasiquote&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scheme&#34;&gt;
(define (cc-graph amount kinds-of-coins)

  (define display-node (lambda (label amount kinds-of-coins)
                         (begin
                           (display &amp;quot;  &amp;quot;)
                           (display label)
                           (display &amp;quot; [label=\&amp;quot;&amp;quot;)
                           (display `(cc ,amount ,kinds-of-coins))
                           (display &amp;quot;\&amp;quot;];&amp;quot;)
                           (newline))))

  (define display-edge (lambda (a b)
                         (begin
                           (display &amp;quot;  &amp;quot;)
                           (display a)
                           (display &amp;quot; -&amp;gt; &amp;quot;)
                           (display b)
                           (display &amp;quot;;&amp;quot;)
                           (newline))))

  (define base-case (lambda (amount kinds-of-coins)
                      (or (&amp;lt; amount 0)
                          (= kinds-of-coins 0)
                          (= amount 0))))

  (define left (lambda (label)
                  (string-append label &amp;quot;l&amp;quot;)))

  (define right (lambda (label)
                  (string-append label &amp;quot;r&amp;quot;)))


  ; label is the unique label of the function invocation
  (define (recurse label amount kinds-of-coins)
    (if (base-case amount kinds-of-coins)
        (display-node label amount kinds-of-coins)
        (begin
          (display-node label amount kinds-of-coins)
          (display-edge label (left label))
          (display-edge label (right label))
          (recurse (left label) amount (- kinds-of-coins 1))
          (recurse (right label)
                   (- amount (first-denomination kinds-of-coins))
                   kinds-of-coins))))

  (begin
    (display &amp;quot;digraph {&amp;quot;)
    (newline)
    (recurse &amp;quot;s&amp;quot; amount kinds-of-coins)
    (newline)
    (display &amp;quot;}&amp;quot;)))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally, the output of running &lt;code&gt;(cc-graph 11 5)&lt;/code&gt;, then piping the
results into GraphViz gives the desired tree:&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/cc_11_5.png %}&lt;/p&gt;

&lt;p&gt;I love this way of visualizing recursion, you can see how the problem
is reduced into simpler sub-problems, and that there is a distinct
&amp;lsquo;shape&amp;rsquo; to the computation.&lt;/p&gt;

&lt;p&gt;There are more than 100 edges in that tree, I would not have wanted to
do that by hand, all for a measley value of four.&lt;/p&gt;

&lt;p&gt;The final value of &lt;code&gt;(cc 11 5)&lt;/code&gt; is 4, that is, there are 4 ways of
making change for 11 cents. Unfortunately, this solution doesn&amp;rsquo;t say
what exact combinations of coins, only that there are four.&lt;/p&gt;

&lt;p&gt;Just thinking about it, you can make 11 cents with&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;11 pennies&lt;/li&gt;
&lt;li&gt;6 pennies, 1 nickel&lt;/li&gt;
&lt;li&gt;1 penny, 2 nickels&lt;/li&gt;
&lt;li&gt;1 penny, 1 dime&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would like to generalize &lt;code&gt;cc-graph&lt;/code&gt; so that I can get a
visualization of any recursive function in Scheme, this will take more
knowledge of the language and it&amp;rsquo;s introspective features, stay tuned!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hooking Jenkins up to a computer-controlled light switch</title>
      <link>/blog/2013/03/18/hooking-jenkins-up-to-a-computer-controlled-light-switch/</link>
      <pubDate>Mon, 18 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/03/18/hooking-jenkins-up-to-a-computer-controlled-light-switch/</guid>
      <description>&lt;p&gt;About a week ago I &lt;a href=&#34;/blog/2013/03/10/make-a-computer-controlled-light-switch-with-a-raspberry-pi/&#34;&gt;wrote about how to hook up a light switch to a raspberry pi&lt;/a&gt;. Having a computer-controlled light switch is nice, but the novelty wears off pretty quickly. The next question that arises usually is &lt;em&gt;how can I make this useful?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;At work, our continuous integration server, which runs &lt;a href=&#34;http://jenkins-ci.org/&#34;&gt;Jenkins&lt;/a&gt;, lets us know when one of the team members has broken the build. To make sure that we get the memo promptly so we can commence with the public shaming, we use tools that change color to indicate the current test status.&lt;/p&gt;

&lt;p&gt;The problem with our current way of doing things is that there is no sound, and it requires that someone be at their computer. To remedy this situation, we wired up physical lights to a raspberry pi running a Debian GNU/Linux variant, and wrote this script to toggle the lights.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On means Passing  (all jobs passed)&lt;/li&gt;
&lt;li&gt;Off means Failing (at least one job failed)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The data flows from Jenkins to the Raspberry-Pi as follows:&lt;/p&gt;

&lt;div style=&#34;width:300px;margin:auto&#34;&gt;
{% img /images/blogimg/tds.png %}
&lt;/div&gt;

&lt;p&gt;gpio stands for (General Purpose Input/Output), the utility is part of the &lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/&#34;&gt;wiringPi&lt;/a&gt; package&lt;/p&gt;

&lt;p&gt;NOTE: You need to set the following environment variables:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;JENKINS_USERNAME&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;JENKINS_PASSWORD&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;JENKINS_HOSTNAME&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://ruby-lang.org&#34;&gt;Ruby&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://projects.drogon.net/raspberry-pi/wiringpi/&#34;&gt;wiringPi&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl --user $JENKINS_USERNAME:$JENKINS_PASSWORD $JENKINS_HOSTNAME/api/json 2&amp;gt; /dev/null                      |   # (Jenkins Job Statuses)

ruby -rjson -e &#39;puts (JSON.parse(STDIN.read)[&amp;quot;jobs&amp;quot;].map{|j| j[&amp;quot;color&amp;quot;]}.all?{|c| c==&amp;quot;blue&amp;quot;} ? &amp;quot;up&amp;quot;:&amp;quot;down&amp;quot;)&#39; |   # (JSON parser/extractor) 

while read line; do   gpio write 4 $line;     done                                                               # (gpio utility)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script runs on the raspberry pi itself.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unmarshalling a list of JSON objects of different type in Go</title>
      <link>/blog/2013/03/17/unmarshalling-a-list-of-json-objects-of-different-type-in-go/</link>
      <pubDate>Sun, 17 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/03/17/unmarshalling-a-list-of-json-objects-of-different-type-in-go/</guid>
      <description>&lt;p&gt;This post started with mattyw&amp;rsquo;s blog post &lt;a href=&#34;http://mattyjwilliams.blogspot.co.uk/2013/01/using-go-to-unmarshal-json-lists-with.html&#34;&gt;Using go to unmarshal json lists with multiple types&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To summarize the article, we are given a JSON string of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;things&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;,
            &amp;quot;age&amp;quot;: 37
        },
        {
            &amp;quot;city&amp;quot;: &amp;quot;Ipoh&amp;quot;,
            &amp;quot;country&amp;quot;: &amp;quot;Malaysia&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Bob&amp;quot;,
            &amp;quot;age&amp;quot;: 36
        },
        {
            &amp;quot;city&amp;quot;: &amp;quot;Northampton&amp;quot;,
            &amp;quot;country&amp;quot;: &amp;quot;England&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our goal is to unmarshal it into a Go data structure. The article goes into more detail, and two solutions were proposed. A commenter came up with a third solution, and another commenter &lt;a href=&#34;https://github.com/dustin/&#34;&gt;dustin&lt;/a&gt; proposed using his library called &lt;a href=&#34;https://github.com/dustin/go-jsonpointer&#34;&gt;jsonpointer&lt;/a&gt;, which operates on the raw byte array of the json string, instead of unmarshalling first and then traversing the data structure.&lt;/p&gt;

&lt;p&gt;I used Dustin&amp;rsquo;s library, and to great avail, the only gotcha was that json strings were returned with the double quotes in them and some trailing spaces, but I made a little function that returned a slice of the original bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func trimJsonBytes(toTrim []byte) []byte {
    // implementation found in solution.go
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loop i:=0,1,2,...∞
  if  /things/i/name  is empty
    make a person
    append it to the person array

  else if /things/i/city is empty
    make a place
    append it to the places array

  else 
    end of array, break out of loop

end loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full source code can be found &lt;a href=&#34;https://github.com/tlehman/json_unmarshall_blogchallenge&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Make a computer-controlled light switch with a Raspberry Pi</title>
      <link>/blog/2013/03/10/make-a-computer-controlled-light-switch-with-a-raspberry-pi/</link>
      <pubDate>Sun, 10 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/03/10/make-a-computer-controlled-light-switch-with-a-raspberry-pi/</guid>
      <description>&lt;p&gt;To build a computer-controlled light switch, you will need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt; ($35)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.adafruit.com/products/268&#34;&gt;Adafruit Powerswitch Tail 2&lt;/a&gt; ($25)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The powerswitch tail looks like an extension cord with some holes in it to wire it into your own circuit. Connect the powerswitch to the raspberry pi as in the image below (on is connected to pin 23):&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/rasbpi_adafruit.jpg %}&lt;/p&gt;

&lt;p&gt;Then, the following python program will allow you to type &lt;code&gt;./switch on&lt;/code&gt; or &lt;code&gt;./switch off&lt;/code&gt; from the command line as root.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# Turn switch on/off
# by tlehman

import RPi.GPIO as io
import sys

io.setmode(io.BCM)
pin = 23
io.setwarnings(False)
io.setup(pin, io.OUT)                 # set pin 23 as output

if len(sys.argv) &amp;gt; 1:
    state = sys.argv[1]               # get command line argument (&#39;on&#39; or &#39;off&#39;)
    io.output(pin, state == &#39;on&#39;)     # if state is on, let pin 23 connect the circuit, otherwise break the circuit
else:
    print(&amp;quot;Usage: &amp;quot;)
    print(&amp;quot;  ./switch (on|off)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run this, carefully plug in a lamp (or other appliance that uses a standard 120V U.S. outlet), then&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo su
./switch on
./switch off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a video of the light being switched off and then back on, not very exciting, but it works:&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;http://www.youtube.com/embed/IO_BZ0mRYyQ&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;This on it&amp;rsquo;s own is not very useful or amusing, but this can easily be tied together with any API or command line utility. For example, I plan to connect this to our continuous integration server at work so that every time the tests fail, the switch turns some lights off, this could be achieved with a cron job, or perhaps a hook on Jenkins that sends a signal to the raspberry pi, there are so many possbilities.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Extract array of frames from mp4 using Python OpenCV bindings</title>
      <link>/blog/2013/01/20/extract-array-of-frames-from-mp4-using-python-opencv-bindings/</link>
      <pubDate>Sun, 20 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/01/20/extract-array-of-frames-from-mp4-using-python-opencv-bindings/</guid>
      <description>

&lt;p&gt;OpenCV is a mature Computer Vision library written in C++. There are python bindings available that make working with the library very convenient.&lt;/p&gt;

&lt;p&gt;To extract the frames from an mp4 file using the Python OpenCV bindings, you first need python, and the &lt;code&gt;pip&lt;/code&gt; package manager for python.&lt;/p&gt;

&lt;p&gt;Also, you will need a system package manager such as Portage for Gentoo Linux or Homebrew for Mac OS X. You will need to compile OpenCV with your specific python version, for this example I am using python 2.7, you can find out which version you have by running &lt;code&gt;python --version&lt;/code&gt;. This example will use Mac OS X 10.8.&lt;/p&gt;

&lt;h2 id=&#34;install-ffmpeg&#34;&gt;Install ffmpeg&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install ffmpeg
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-opencv-with-python2-7-and-ffmpeg&#34;&gt;Build OpenCV with Python2.7 and ffmpeg&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;brew install opencv --python27 --ffmpeg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am taking the &lt;a href=&#34;https://www.coursera.org/course/images&#34;&gt;Coursera Image and Video processing&lt;/a&gt; class right now, the example file I am using is one of &lt;a href=&#34;https://class.coursera.org/images-2012-001/lecture/download.mp4?lecture_id=7&#34;&gt;the lectures&lt;/a&gt;, I saved the file as &lt;code&gt;course-logistics.mp4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To use OpenCV in python, you need to import cv2:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cv2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, to open the video file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;vidcap = cv2.VideoCapture(&#39;course-logistics.mp4&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The easiest way to extract frames is to use the &lt;code&gt;read()&lt;/code&gt; method on the vidcap object. It returns a &lt;a href=&#34;http://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences&#34;&gt;tuple&lt;/a&gt; where the first element is a success flag and the second is the image array. To extract the image array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;success,image = vidcap.read()
# image is an array of array of [R,G,B] values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To convert the whole video to frames and save each one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;count = 0; 
while success:
	success,image = vidcap.read()
	cv2.imwrite(&amp;quot;frame%d.jpg&amp;quot; % count, image)     # save frame as JPEG file
	if cv2.waitKey(10) == 27:                     # exit if Escape is hit
    	break
	count += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above loop runs until &lt;code&gt;success&lt;/code&gt; is false or the user hits the Escape key. Each iteration saves the current frame as a JPEG.&lt;/p&gt;

&lt;p&gt;This is one way to extract a sequence of frames from a movie. Another way would be to change the body of the above while loop to do something else.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building command line utilities in Ruby that play well with Unix</title>
      <link>/blog/2012/12/30/building-command-line-utilities-in-ruby-that-play-well-with-the-rest-of-the-unix-utilities/</link>
      <pubDate>Sun, 30 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/12/30/building-command-line-utilities-in-ruby-that-play-well-with-the-rest-of-the-unix-utilities/</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Pipeline_%28Unix%29&#34;&gt;Unix pipeline&lt;/a&gt; is a beautiful thing, as long as Standard Input and Standard Output are handled correctly, programs can be kept small and predictable. Getting any sort of complex functionality is simply a matter of composing the appropriate command line utilties via the Unix pipeline.&lt;/p&gt;

&lt;p&gt;When taking &lt;a href=&#34;https://www.coursera.org/course/crypto&#34;&gt;Coursera&amp;rsquo;s Cryptography I class&lt;/a&gt;, I learned about how all substitution ciphers could be cracked using character frequency analysis. Basically, in English plaintext, there is a very non-uniform distribution over the alphabet, as you can see here:&lt;/p&gt;

&lt;p&gt;{% img &lt;a href=&#34;http://upload.wikimedia.org/wikipedia/commons/b/b0/English_letter_frequency_%28frequency%29.svg&#34;&gt;http://upload.wikimedia.org/wikipedia/commons/b/b0/English_letter_frequency_%28frequency%29.svg&lt;/a&gt; r%}&lt;/p&gt;

&lt;p&gt;Using this, no matter how you scramble up the alphabet, given enough ciphertext, you can use this distribution to figure out how the alphabet was scrambled.&lt;/p&gt;

&lt;p&gt;As I learned this, I wanted to test it on real data sets like Sherlock Holmes and Beowulf. There was a lot of English text, so I looked around for a command line utility that counted character or word frequency. I couldn&amp;rsquo;t find one, so I whipped together a ruby program.&lt;/p&gt;

&lt;p&gt;Aside from substitution ciphers, I like knowing word and character frequencies for other reasons, and I was a bit annoyed that such a thing didn&amp;rsquo;t exist, so I made one. Since I&amp;rsquo;ve been doing Ruby development for about a year, I thought it was about time to learn how ruby gems are born.&lt;/p&gt;

&lt;p&gt;Buildling a gem is very easy, one just has to run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; bundle gem foo
      create  foo/Gemfile
      create  foo/Rakefile
      create  foo/LICENSE.txt
      create  foo/README.md
      create  foo/.gitignore
      create  foo/foo.gemspec
      create  foo/lib/foo.rb
      create  foo/lib/foo/version.rb
Initializating git repo in /Users/tobi/foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, cd into the &lt;code&gt;foo&lt;/code&gt; directory, hack away on the code, and then do a &lt;code&gt;rake release&lt;/code&gt;, which publishes to rubygems.org. Then, anyone else can just run &lt;code&gt;gem install foo&lt;/code&gt; and start using your program.&lt;/p&gt;

&lt;p&gt;I wrote a gem called wordfreq that computed the word or character frequencies (if the -c flag was given), this was a quick way to verify the distribution above for the alphabet.&lt;/p&gt;

&lt;p&gt;The thing I got hung up on was the Errno::EPIPE exception in Ruby. When I wrote wordfreq and then piped its output to &lt;code&gt;head&lt;/code&gt;, the Errno::EPIPE exception was thrown. I thought I was doing something wrong, but it turned out that I just needed to handle that exception, since utilities like &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; stop reading after 10 lines. When &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;tail&lt;/code&gt; stops reading, Ruby throws an Errno::EPIPE exception. The way I solved the problem was to handle the Errno::EPIPE exception by breaking out of the main loop.&lt;/p&gt;

&lt;p&gt;Here is the github repository with the source code and documentation: &lt;a href=&#34;https://github.com/tlehman/wordfreq&#34;&gt;https://github.com/tlehman/wordfreq&lt;/a&gt;, or if you want to start using it, just run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install wordfreq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Publishing gems is very easy with Bundler, and it is a great way to make small command line utilities. But make sure you respond appropriately when pipes close, that way your command lime tool will mesh nicely with the rest of the Unix tools.&lt;/p&gt;

&lt;h2 id=&#34;further-reading&#34;&gt;Further Reading:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jstorimer.com/2011/12/12/writing-ruby-scripts-that-respect-pipelines.html&#34;&gt;Writing Ruby Scripts That Respect Pipelines (J. Storimer)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/aix/library/au-spunix_pipeviewer/&#34;&gt;Speaking Unix: Peering into Pipes (M. Streicher)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What languages fix: graphically</title>
      <link>/blog/2012/12/26/what-languages-fix-graphically/</link>
      <pubDate>Wed, 26 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/12/26/what-languages-fix-graphically/</guid>
      <description>&lt;p&gt;Paul Graham&amp;rsquo;s article &lt;a href=&#34;http://www.paulgraham.com/fix.html&#34;&gt;What languages fix&lt;/a&gt; is about Kevin Kelleher&amp;rsquo;s description of each programming language in terms of the problems with other languages that it fixes. I decided to make this into a graph where each node is a language, and the edge represents the relation &amp;ldquo;x fixes y&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Here is the list:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Algol: Assembly language is too low-level.&lt;/li&gt;
&lt;li&gt;Pascal: Algol doesn&amp;rsquo;t have enough data types.&lt;/li&gt;
&lt;li&gt;Modula: Pascal is too wimpy for systems programming.&lt;/li&gt;
&lt;li&gt;Simula: Algol isn&amp;rsquo;t good enough at simulations.&lt;/li&gt;
&lt;li&gt;Smalltalk: Not everything in Simula is an object.&lt;/li&gt;
&lt;li&gt;Fortran: Assembly language is too low-level.&lt;/li&gt;
&lt;li&gt;Cobol: Fortran is scary.&lt;/li&gt;
&lt;li&gt;PL/1: Fortran doesn&amp;rsquo;t have enough data types.&lt;/li&gt;
&lt;li&gt;Ada: Every existing language is missing something.&lt;/li&gt;
&lt;li&gt;Basic: Fortran is scary.&lt;/li&gt;
&lt;li&gt;APL: Fortran isn&amp;rsquo;t good enough at manipulating arrays.&lt;/li&gt;
&lt;li&gt;J: APL requires its own character set.&lt;/li&gt;
&lt;li&gt;C: Assemby language is too low-level.&lt;/li&gt;
&lt;li&gt;C++: C is too low-level.&lt;/li&gt;
&lt;li&gt;Java: C++ is a kludge. And Microsoft is going to crush us.&lt;/li&gt;
&lt;li&gt;C#: Java is controlled by Sun.&lt;/li&gt;
&lt;li&gt;Lisp: Turing Machines are an awkward way to describe computation.&lt;/li&gt;
&lt;li&gt;Scheme: MacLisp is a kludge.&lt;/li&gt;
&lt;li&gt;T: Scheme has no libraries.&lt;/li&gt;
&lt;li&gt;Common Lisp: There are too many dialects of Lisp.&lt;/li&gt;
&lt;li&gt;Dylan: Scheme has no libraries, and Lisp syntax is scary.&lt;/li&gt;
&lt;li&gt;Perl: Shell scripts/awk/sed are not enough like programming languages.&lt;/li&gt;
&lt;li&gt;Python: Perl is a kludge.&lt;/li&gt;
&lt;li&gt;Ruby: Perl is a kludge, and Lisp syntax is scary.&lt;/li&gt;
&lt;li&gt;Prolog: Programming is not enough like logic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I put the above text into a file called &amp;lsquo;fix.txt&amp;rsquo; and then wrote the following ruby code to convert it into a directed graph in the DOT language:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# make a graph of language solutions (inspired by: http://www.paulgraham.com/fix.html)

fixes = File.open(&#39;fix.txt&#39;).read.split(&amp;quot;\n&amp;quot;)

fixes.each do |fix|
  language = fix.split(&amp;quot;:&amp;quot;).first
  /\:(?&amp;lt;fixed&amp;gt;.*)\b(is(n&#39;t)?|are|doesn&#39;t)\b/ =~ fix
  puts &amp;quot;#{language} -&amp;gt; #{fixed} [label=\&amp;quot;fixes\&amp;quot;]&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had to tweak the output a bit, but the final result is a very nice summation of Kelleher&amp;rsquo;s list:
&lt;a href=&#34;/images/blogimg/lang_fixes.png&#34;&gt;&lt;img src=&#34;/images/blogimg/lang_fixes.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unix Processes and Their Parents Part 2</title>
      <link>/blog/2012/10/28/unix-processes-and-their-parents-part-2/</link>
      <pubDate>Sun, 28 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/10/28/unix-processes-and-their-parents-part-2/</guid>
      <description>&lt;p&gt;Based on a comment by Mark Essel from &lt;a href=&#34;/blog/2012/10/14/unix-processes-and-their-parents/&#34;&gt;part 1&lt;/a&gt; I have been trying
to add more metadata to the process tree. I have given up on doing it in a one-liner, so I started using bash scripts.&lt;/p&gt;

&lt;p&gt;Then, after a few hours of hacking bash, I got annoyed with the difficulty of very basic things such as incrementing
integers and dealing with collections, so I switched over to Ruby, with some minor shelling out.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href=&#34;https://github.com/tlehman/procviz&#34;&gt;procviz&lt;/a&gt;, it is some ruby code for generating a graph representing
the process tree at the time &lt;code&gt;Graph.new&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;It generates DOT files just fine, but the images can get big if your system has a lot of stuff running. Also, the only
metadata I have attached to the nodes so far is the command name:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/images/blogimg/proc_with_names.png&#34;&gt;
  &lt;img src=&#34;/images/blogimg/proc_with_names.png&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I wanted to make this into a more interactive visualization, but so far I have had a hard time getting Sigma.js or Arbor.js
to embed into this Octopress blog. I have been meaning to get a better understanding of javascript.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualizing Unix processes and their parents</title>
      <link>/blog/2012/10/14/unix-processes-and-their-parents/</link>
      <pubDate>Sun, 14 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/10/14/unix-processes-and-their-parents/</guid>
      <description>&lt;p&gt;I am reading Jesse Storimer&amp;rsquo;s fantastic little book &lt;a href=&#34;http://workingwithunixprocesses.com/&#34;&gt;&amp;ldquo;Working with Unix Processes&amp;rdquo;&lt;/a&gt; right now, and inspiration struck after the second chapter &amp;ldquo;Processes Have Parents&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;When a Unix process is born, it is a literal copy of it&amp;rsquo;s parent process. For example, if I am typing &lt;em&gt;ls&lt;/em&gt; into a bash prompt, the bash process spawns a copy of itself using the &lt;em&gt;fork&lt;/em&gt; system call. The parent process (bash) has an id which is associated with the child process (ls). Using the Unix &lt;em&gt;ps&lt;/em&gt; command, you can see the parent process id of every process on the system.&lt;/p&gt;

&lt;p&gt;The only process that has no parent is &lt;em&gt;sched&lt;/em&gt;, it has process id zero. The idea I had was to make a visualization of this branching tree of Unix processes. I am currently running Debian GNU/Linux, a Unix-like operating system. I came up with this one-liner that shows the (parent id -&amp;gt; child id) relation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot; | grep -v &amp;quot;PID&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first part calls &lt;em&gt;ps&lt;/em&gt; and gets all process ids, and their parents. Some sample output is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ &amp;gt; ps axo ppid,pid
 PPID   PID
    0     1
    0     2
    2     3
    2     6
    2     7
    2     8
    2    10
    2    12
    2    13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This output is piped into &lt;em&gt;sed&lt;/em&gt; (*s*tream *ed*itor), and the empty space between the numbers is replaced with an arrow &amp;ldquo;-&amp;gt;&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ &amp;gt; ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot;
 PPID -&amp;gt;   PID
    0 -&amp;gt;     1
    0 -&amp;gt;     2
    2 -&amp;gt;     3
    2 -&amp;gt;     6
    2 -&amp;gt;     7
    2 -&amp;gt;     8
    2 -&amp;gt;    10
    2 -&amp;gt;    12
    2 -&amp;gt;    13
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PPID is Parent Process Id, and PID is just Process Id. Finally, I use &lt;em&gt;grep -v &amp;ldquo;PID&amp;rdquo;&lt;/em&gt; to let all the lines through that don&amp;rsquo;t contain &amp;ldquo;PID&amp;rdquo;. This selects those lines that are actual process relations.&lt;/p&gt;

&lt;p&gt;In this case, it just chops off the first line. Next, I wanted to convert this into a file that I can feed into &lt;a href=&#34;http://www.graphviz.org/&#34;&gt;GraphViz&lt;/a&gt;, an open source graph visualization tool. The format is pretty simple, an example is in order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digraph Foo {
  1 -&amp;gt; 2
  1 -&amp;gt; 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above file defines a graph called &amp;ldquo;Foo&amp;rdquo; that has three nodes and two edges, it looks like this:&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/Foo.png %}&lt;/p&gt;

&lt;p&gt;Now, all we have to do to the PPID-&amp;gt;PID output above is to wrap it in braces and prepend two words to the beginning.&lt;/p&gt;

&lt;p&gt;We can use &lt;em&gt;echo &amp;ldquo;digraph proc { SOME COMMAND }&amp;rdquo;&lt;/em&gt; to wrap the output of our command, then dump the results in a file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &amp;quot;digraph proc { `ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot; | grep -v &amp;quot;PID&amp;quot;` } &amp;quot; &amp;gt;&amp;gt; proc.dot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, GraphViz has several commands for rendering graphs in various ways. The first thing I tried was a symmetric layout, but that produced a hierarchical, &lt;em&gt;very wide&lt;/em&gt; image. So I tryed &lt;em&gt;circo&lt;/em&gt; which produces a radial layout:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~ &amp;gt; echo &amp;quot;digraph proc { `ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot; | grep -v &amp;quot;PID&amp;quot;` } &amp;quot; &amp;gt;&amp;gt; proc.dot
~ &amp;gt; circo proc.dot -Tpng &amp;gt;&amp;gt; radial_proc.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the radial layout:
{% img /images/blogimg/radial_proc.png %}&lt;/p&gt;

&lt;p&gt;You can see the original ancestor of all processes, &lt;em&gt;sched&lt;/em&gt; with PID 0 right in the center, then PID 1 which is called &lt;em&gt;init&lt;/em&gt; has a bunch of children. I am writing this post in vim in a bash shell in a gnome terminal emulator, the vim PID is 14819, but it is hard to see in this image, there is too much overlap.&lt;/p&gt;

&lt;p&gt;Fortunately, we can modify the proc.dot file and include &lt;em&gt;overlap=false&lt;/em&gt; right above the PPID-&amp;gt;PID pairs. Also, I found from the man pages for the graphviz tools that the &lt;em&gt;splines=true&lt;/em&gt; option will draw the edges as splines (curves) instead of straight lines. Also, instead of using &lt;em&gt;circo&lt;/em&gt;, there is another tool called &lt;em&gt;neato&lt;/em&gt; that will render a more symmetrical graph than circo.&lt;/p&gt;

&lt;p&gt;This rendering took &lt;em&gt;much&lt;/em&gt; longer than circo rendering, but is much nicer (click to enlarge):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/images/blogimg/sym_proc.png&#34;&gt;
  &lt;img src=&#34;/images/blogimg/sym_proc.png&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I remember learning in my C programming class that Unix processes all had to be made with fork. It reminded me of asexual reproduction where two identical copies are made. I look forward to learning more about the Unix process model, and recommend Jesse&amp;rsquo;s book.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>