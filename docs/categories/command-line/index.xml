<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Command Line on tlehman@home</title>
    <link>/categories/command-line/index.xml</link>
    <description>Recent content in Command Line on tlehman@home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/command-line/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Word frequencies after removing common words</title>
      <link>/blog/2015/02/10/word-frequencies-after-removing-common-words/</link>
      <pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/2015/02/10/word-frequencies-after-removing-common-words/</guid>
      <description>

&lt;p&gt;In taking the &lt;a href=&#34;https://class.coursera.org/mmds-002&#34;&gt;Coursera class on Mining Massive Datasets&lt;/a&gt;, the problem of computing word frequency for very large documents came up. I wanted some convenient tools for breaking documents into streams of words, and also a tool to remove common words like &amp;lsquo;the&amp;rsquo;, so I wrote up &lt;code&gt;words&lt;/code&gt; and &lt;code&gt;decommonize&lt;/code&gt;. The &lt;code&gt;decommonize&lt;/code&gt; script is just a big &lt;code&gt;grep -v &#39;(foo|bar|baz)&#39;&lt;/code&gt;, where the words foo, bar and baz come from the words in a file. I made a script &lt;code&gt;generate_decommonize&lt;/code&gt; that reads in a list of common words, and builds the regex for &lt;code&gt;grep -v&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;example-usage-of-words-and-decommonize&#34;&gt;Example usage of &lt;code&gt;words&lt;/code&gt; and &lt;code&gt;decommonize&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;The full source code is available &lt;a href=&#34;https://github.com/tlehman/words&#34;&gt;here on github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;After running &lt;code&gt;make install&lt;/code&gt;, you should have &lt;code&gt;words&lt;/code&gt; and &lt;code&gt;decommonize&lt;/code&gt; in your PATH, you can use them to find key words that are characteristic of a document, I chose&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the U.S. Declaration of Independence:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
$ words &lt; declaration_of_independence.txt | decommonize  | sort | uniq -c | sort -n | tail
   4 time
   5 among
   5 most
   5 powers
   6 government
   6 such
   7 right
   8 states
   9 laws
  10 people
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Sherlock Holmes&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
$ words &lt; doyle_sherlock_holmes.txt | decommonize  | sort | uniq -c | sort -n | tail
 174 think
 175 more
 177 over
 212 may
 212 should
 269 little
 274 mr
 288 man
 463 holmes
 466 upon
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Working with Unix Processes (by @jstorimer)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
$ words &lt; working_with_unix_processes.txt | decommonize  | sort | uniq -c | sort -n | tail
  73 signal
  82 system
  88 ruby
  90 exit
 100 code
 100 parent
 143 its
 146 child
 184 processes
 444 process
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;words&lt;/code&gt; breaks up the document into lower-case alphabetic words, then &lt;code&gt;decommonize&lt;/code&gt; greps out the common words, and &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;uniq -c&lt;/code&gt; are used to count instances of each decommonized word, and then the results are sorted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git log-display: step backward through your git commits displaying diffs</title>
      <link>/blog/2014/11/28/git-log-display-step-backward-through-your-git-commits-displaying-diffs/</link>
      <pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/11/28/git-log-display-step-backward-through-your-git-commits-displaying-diffs/</guid>
      <description>

&lt;p&gt;When working with git at the command line, I frequently want to see the last changes made to a repository. To see the result of the last commit (diff&amp;rsquo;d with it&amp;rsquo;s parent commit), you can just type &lt;code&gt;git show&lt;/code&gt;. Git assumes the &lt;code&gt;HEAD&lt;/code&gt; pointer and just spits it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;$ git show
commit 112379bca37e89c719c54be1598eeea5dbeede82
Author: Tobi Lehman &amp;lt;tlehman@example.com&amp;gt;
Date:   Thu Nov 20 10:31:59 2014 -0800

    add -r flag to regenerate fastroutes file

diff --git a/fastroutes b/fastroutes
index 55920ce..666a2ab 100755
--- a/fastroutes
+++ b/fastroutes
@@ -39,6 +39,10 @@ function main {
 if [[ &amp;quot;$1&amp;quot; == &amp;quot;-f&amp;quot; ]]
 then
   show_current_filename
+elif [[ &amp;quot;$1&amp;quot; == &amp;quot;-r&amp;quot; ]]
+then
+  rm $cached_routes_filename
+  cache_routes
 else
   main
 fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes I want to step back through all the commits though, I can run &lt;code&gt;git show HEAD^&lt;/code&gt; and &lt;code&gt;git show HEAD^^&lt;/code&gt;, and keep appending &lt;code&gt;^&lt;/code&gt; characters, but that gets old fast. Also, sometimes I just want to look at the commits that changed a file.&lt;/p&gt;

&lt;p&gt;To solve this, I wrote &lt;a href=&#34;https://github.com/tlehman/bin/blob/master/git-log-display&#34;&gt;git log-display&lt;/a&gt;. Here&amp;rsquo;s an example to see how it can be used:&lt;/p&gt;

&lt;h3 id=&#34;git-log-display&#34;&gt;git log-display&lt;/h3&gt;

&lt;p&gt;To see all the commits from HEAD all the way back to initial commit, run &lt;code&gt;git log-display&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blogimg/git-log-display.gif&#34;&gt;&lt;/p&gt;

&lt;p&gt;To step back through commits, hit &amp;lsquo;q&amp;rsquo;, and to exit press &amp;lsquo;Ctrl-C&amp;rsquo;&lt;/p&gt;

&lt;h3 id=&#34;git-log-display-filename&#34;&gt;git log-display FILENAME&lt;/h3&gt;

&lt;p&gt;To see all the commits that make modifications to &lt;code&gt;FILENAME&lt;/code&gt;, just run &lt;code&gt;git log-display $FILENAME&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/blogimg/git-log-display-filename.gif&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;git-subcommands&#34;&gt;git subcommands&lt;/h3&gt;

&lt;p&gt;One nice thing about git is that you can make a subcommand &lt;code&gt;git foo&lt;/code&gt; just by having an executable called &lt;code&gt;git-foo&lt;/code&gt; somewhere in your &lt;code&gt;PATH&lt;/code&gt; variable. So to install this, just copy &lt;code&gt;git-log-display&lt;/code&gt; to a directory in your &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>script for logging standing desk state transitions</title>
      <link>/blog/2014/08/18/script-for-logging-standing-desk-state-transitions/</link>
      <pubDate>Mon, 18 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/08/18/script-for-logging-standing-desk-state-transitions/</guid>
      <description>&lt;p&gt;At work I have an adjustible-height desk, that way it can be both a standing or a sitting desk.
In order to better understand my own usage habits, I made the &lt;a href=&#34;https://github.com/tlehman/bin#desk&#34;&gt;desk&lt;/a&gt; script,
 which logs state transitions.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;desk up&lt;/code&gt; records the time that the desk was moved up into a standing position, and &lt;code&gt;desk down&lt;/code&gt; records the
time the desk was moved into the sitting position. Later, when I have a few months of data, I&amp;rsquo;ll do some analysis and
see what the probabilities are in the following state transition diagram:&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/desk.png %}&lt;/p&gt;

&lt;p&gt;The script builds a CSV file, and implements a simple interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;desk up    # log transition to &amp;quot;up&amp;quot; state at current time
desk down  # log transition to &amp;quot;down&amp;quot; state at current time
desk log   # show last 5 state transitions along with time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the source code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;log_filename=&amp;quot;/path/to/log/file&amp;quot;

function create_log_file_if_not_exists {
  if [ ! -e $log_filename ]
  then
    echo &amp;quot;timestamp,state&amp;quot; &amp;gt; $log_filename
  fi
}

function log_new_state {
  create_log_file_if_not_exists

  local state=$1
  local timestamp=$(date --iso-8601=seconds)

  echo &amp;quot;$timestamp,$state&amp;quot; &amp;gt;&amp;gt; $log_filename
}

function show_log {
  create_log_file_if_not_exists

  echo &amp;quot;timestamp                 state&amp;quot;
  awk &amp;lt; $log_filename -F, &#39;NR &amp;gt; 1 {print $1&amp;quot;  &amp;quot;$2}&#39; | tail -5
}

if [ $1 = &amp;quot;up&amp;quot; ] || [ $1 = &amp;quot;down&amp;quot; ]
then
  log_new_state $1
elif [ $1 = &amp;quot;log&amp;quot; ]
then
  show_log
else
  echo &amp;quot;Invalid command: $1&amp;quot;
  exit 1
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will allow me to use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Markov_chain&#34;&gt;Markov chain&lt;/a&gt; to model my sitting/standing
habits. More on markov chains in a later blog post.&lt;/p&gt;

&lt;p&gt;On the health benefits (or problems) with standing, I am not a medical professional, but I think alternating sitting
and standing is probably better than all sitting or all standing.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualizing the &#39;belongs to&#39; relation in rails app models</title>
      <link>/blog/2014/07/22/visualizing-the-belongs-to-relation-in-rails-app-models/</link>
      <pubDate>Tue, 22 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>/blog/2014/07/22/visualizing-the-belongs-to-relation-in-rails-app-models/</guid>
      <description>&lt;p&gt;When working on rails apps, I usually have to make a mental map of the models and how they interrelate.&lt;/p&gt;

&lt;p&gt;An Active Record model can belong to another, but when you have more than half a dozen models, keeping all
the belongs_to relations in mind quickly becomes impossible. As a solution to this, I made a command line
program called &lt;a href=&#34;https://github.com/tlehman/bin#argraph&#34;&gt;argraph&lt;/a&gt;, for &amp;lsquo;ActiveRecord graph&amp;rsquo;, it produces a digraph in the
&lt;a href=&#34;http://www.graphviz.org/doc/info/lang.html&#34;&gt;DOT language&lt;/a&gt;, which can be rendered as an image
using &lt;a href=&#34;http://www.graphviz.org/&#34;&gt;GraphViz&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The nodes are models, and the edges are the &amp;lsquo;belongs to&amp;rsquo; relation.&lt;/p&gt;

&lt;p&gt;The way to use it is to check it out or fork my &lt;a href=&#34;https://github.com/tlehman/bin&#34;&gt;bin&lt;/a&gt; repo, make sure that directory
is in your PATH variable, cd to the root of your rails app and run &lt;code&gt;argraph&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As an example, suppose you have the &lt;a href=&#34;https://github.com/discourse/discourse&#34;&gt;discourse&lt;/a&gt; rails app checked out,
and you want to find out how some of it&amp;rsquo;s models are interrelated:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd discourse
$ argraph Post Topic Category PostReply User UserAction UserHistory QuotedPost View UserAvatar
digraph {
 Post -&amp;gt; User
 Post -&amp;gt; Topic
 Topic -&amp;gt; Category
 Topic -&amp;gt; User
 Category -&amp;gt; Topic
 Category -&amp;gt; User
 PostReply -&amp;gt; Post
 UserAction -&amp;gt; User
 QuotedPost -&amp;gt; Post
 QuotedPost -&amp;gt; QuotedPost
 View -&amp;gt; User
 UserAvatar -&amp;gt; User
}
$ !! | dot -Tpng &amp;gt; discourse.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above graph renders as:
&lt;img src=&#34;https://i.imgur.com/YQOyHUn.png&#34; alt=&#34;discourse model graph&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can also run the command with no arguments, in which case it maps out all models, but on bigger apps, this can be hard to follow,
so I found it useful to be able to explore subgraphs containing more models than my memory could fit, but not so many that the image
was polluted and hard to follow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Revisiting spaces in file names</title>
      <link>/blog/2013/10/19/revisiting-spaces-in-file-names/</link>
      <pubDate>Sat, 19 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/10/19/revisiting-spaces-in-file-names/</guid>
      <description>&lt;p&gt;I don&amp;rsquo;t like spaces in file names, as I&amp;rsquo;ve &lt;a href=&#34;/blog/2012/10/29/spaces-in-filenames/&#34;&gt;written before&lt;/a&gt;, and as I&amp;rsquo;ve &lt;a href=&#34;/blog/2012/11/19/fixing-spaces-in-filenames/&#34;&gt;tried in vain to fix&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been working around this issue with a little hack that I call &lt;code&gt;wrap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
# Read in lines, output lines with single quotes around them
#
# Example use:
# 
#   $ &amp;lt;command&amp;gt;
#   output of command
#   the output has spaces
#   spaces are annoying
#
#   $ &amp;lt;command&amp;gt; | wrap
#   &#39;output of command&#39;
#   &#39;the output has spaces&#39;
#   &#39;spaces are annoying&#39;
#

sed -e &amp;quot;s/\(.*\)/&#39;\1&#39;/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It wraps each line with single quotes, however, the obvious problem with this is that sometimes lines have single quotes in them. For file names, it&amp;rsquo;s usually fine, since it&amp;rsquo;s unusual for file names to have quotes in them.&lt;/p&gt;

&lt;p&gt;I recently came across &lt;a href=&#34;https://coderwall.com/p/lhilrq&#34;&gt;this awesome solution&lt;/a&gt; by &lt;a href=&#34;https://coderwall.com/debona&#34;&gt;@debona&lt;/a&gt;,
it uses the &lt;a href=&#34;http://nixshell.wordpress.com/2007/09/26/ifs-internal-field-separator/&#34;&gt;IFS&lt;/a&gt; environment variable. IFS stands for Internal Field Separator.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the problem I run into when looping over a list file files that have spaces in the name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ find ~/Library/Saved\ Application\ State | head -5 | for file in $(cat -); do echo $file; done

/Users/tlehman/Library/Saved
Application
State
/Users/tlehman/Library/Saved
Application
State/com.adobe.Reader.savedState
/Users/tlehman/Library/Saved
Application
State/com.adobe.Reader.savedState/data.data
/Users/tlehman/Library/Saved
Application
State/com.adobe.Reader.savedState/window_2.data
/Users/tlehman/Library/Saved
Application
State/com.adobe.Reader.savedState/windows.plist

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The spaces are seen as delimiters, but by setting IFS to a newline, we can avoid this problem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ IFS=&#39;
&#39;
$ find ~/Library/Saved\ Application\ State | head -5 | for file in $(cat -); do echo $file; done
/Users/tlehman/Library/Saved Application State
/Users/tlehman/Library/Saved Application State/com.adobe.Reader.savedState
/Users/tlehman/Library/Saved Application State/com.adobe.Reader.savedState/data.data
/Users/tlehman/Library/Saved Application State/com.adobe.Reader.savedState/window_2.data
/Users/tlehman/Library/Saved Application State/com.adobe.Reader.savedState/windows.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just the kind of solution I was looking for, props to @debona for writing this up on Coderwall.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>XKCD 1277: Ayn Rand and Regular Expressions</title>
      <link>/blog/2013/10/14/xkcd-1277-ayn-rand-and-regular-expressions/</link>
      <pubDate>Mon, 14 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/10/14/xkcd-1277-ayn-rand-and-regular-expressions/</guid>
      <description>&lt;p&gt;Randall Munroe of XKCD is brilliant, today&amp;rsquo;s comic is no exception:&lt;/p&gt;

&lt;p&gt;{%img &lt;a href=&#34;http://imgs.xkcd.com/comics/ayn_random.png&#34;&gt;http://imgs.xkcd.com/comics/ayn_random.png&lt;/a&gt; %}&lt;/p&gt;

&lt;p&gt;While the Ayn Rand joke is amusing, the real clever joke in the alt text (that maddeningly disappears if you take too long to read)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In a cavern deep below the Earth, Ayn Rand, Paul Ryan, Rand Paul, Ann Druyan, Paul Rudd, Alan Alda, and Duran Duran meet togther in the Secret Council of /(\b[plurandy]+\b ?){2}/i&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For those not familiar with regular expressions, the end of that sentence might look like nonsense, but it encodes the (much more amusing) similarity between all those names:&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with the list of names, assume they are in a file called &lt;code&gt;names&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat names
Ayn Rand
Paul Ryan
Rand Paul
Ann Druyan
Paul Rudd
Alan Alda
Duran Duran
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each of the names, set them to lower case, split up the characters, then sort and count occurences:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat names | xargs ruby -e &#39;puts ARGV.join.downcase.split(//)&#39; | sort | uniq -c
     15 a
      8 d
      5 l
     10 n
      3 p
      7 r
      7 u
      3 y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that there are only 8 unique characters in that list, in &lt;a href=&#34;http://en.wikipedia.org/wiki/Regular_expression&#34;&gt;regular expressions&lt;/a&gt; the syntax &lt;code&gt;[plurandy]&lt;/code&gt; means &amp;lsquo;match any character in the set &lt;code&gt;{p,l,u,r,a,n,d,y}&lt;/code&gt;&amp;lsquo;&lt;/p&gt;

&lt;p&gt;You can see in this diagram how the whole expression works:&lt;/p&gt;

&lt;p&gt;{% img &lt;a href=&#34;https://www.debuggex.com/i/CzkCTSvo1uBAYkyi.png&#34;&gt;https://www.debuggex.com/i/CzkCTSvo1uBAYkyi.png&lt;/a&gt; %}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;/(\b[plurandy]+\b ?){2}/i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The character &lt;code&gt;\b&lt;/code&gt; matches a word boundary, which is a point between a word character and a non-word character, such as the point right before the beginning of the name, or after. The trailing &lt;code&gt;/i&lt;/code&gt; means case insensitive, the diagram explains the rest.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The above graphic is done in &lt;a href=&#34;https://www.debuggex.com/r/CzkCTSvo1uBAYkyi&#34;&gt;Debuggex&lt;/a&gt;, it is a fantastic tool for exploring and debugging regular expressions&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Analyzing Bash History and Fixing Typos</title>
      <link>/blog/2013/06/18/analyzing-bash-history-and-fixing-typos/</link>
      <pubDate>Tue, 18 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/06/18/analyzing-bash-history-and-fixing-typos/</guid>
      <description>&lt;p&gt;At the command line, I frequently type things too fast, and typos abound. A single character can mean the difference between showing documentation and deleting files (&lt;code&gt;rm&lt;/code&gt; vs &lt;code&gt;ri&lt;/code&gt;), so autocorrect is definitely a bad idea in this context.&lt;/p&gt;

&lt;p&gt;Instead of a generic autocorrect, a better idea is to find the most common mistakes. To do so, I used frequency analysis like in &lt;a href=&#34;/blog/2013/01/28/reinventing-the-wheel-or-how-i-learned-to-stop-coding-and-read-the-manpages/&#34;&gt;this post&lt;/a&gt; to narrow down what I use most at the shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat ~/.bash_history | 
     awk -F\| &#39;{print $1}&#39; | 
     sort | 
     uniq -c | 
     sort -n | 
     tail -15

 157 rake routes
 221 dbtt
 232 git fetch -p
 300 rails c
 370 gi ts
 376 g gs
 403 git add .
 405 rails s
 406 git b
 433 exit
 435 git lg
 663 git diff
1112 ls
1898 clear
4486 git s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;gi ts&lt;/code&gt; is extremely common, I meant to type &lt;code&gt;git s&lt;/code&gt; all those 376 times. As a solution, I could just alias it, but I would prefer a more general solution that would handle &lt;code&gt;gi tdiff&lt;/code&gt; and &lt;code&gt;gi tb&lt;/code&gt; as &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git b&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;I made the following script called &lt;code&gt;~/bin/gi&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh

if   [[ $1 =~ &#39;ts&#39; ]]; then
  git s
elif [[ $1 =~ &#39;tb&#39; ]]; then
  git b 
elif [[ $1 =~ &#39;tdiff&#39; ]]; then
  git diff
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So that &lt;code&gt;gi ts&lt;/code&gt; is no longer a mistake, it means what I meant it to mean. This saves me a few keystrokes, and it is a good example of why scripts in your path are generally better than aliases, since you can have logic in them.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How many possible flags are there?</title>
      <link>/blog/2013/05/11/how-many-possible-flags-are-there/</link>
      <pubDate>Sat, 11 May 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/05/11/how-many-possible-flags-are-there/</guid>
      <description>

&lt;p&gt;I have been thinking about Mars a lot more lately, and about possible colonization. The &lt;a href=&#34;http://mars-one.com/&#34;&gt;Mars One&lt;/a&gt; project is a non-governmental not-for-profit organization that is looking to send groups of four people, independent of nationality, to Mars in 2023.&lt;/p&gt;

&lt;p&gt;One thing that came to mind was independence, just as the early North American settlers declared independence from Great Britain, I think that Martian settlers would eventually declare independence from the countries of Earth, provided they had a sustainable, self-reliant colony.&lt;/p&gt;

&lt;p&gt;As a side effect, the Martian settlers would probably choose a new flag, and then the math geek in me wondered how far this could go, &lt;strong&gt;how many different flags are possible?&lt;/strong&gt; As humanity grows, evolves and expands, assuming that each nation that emerged had a flag, how many unique flags could possibly be created?&lt;/p&gt;

&lt;p&gt;If we allow for any arbitrary size and aspect ratio, the number is infinite. However, most flags have the same aspect ratio, and their implementation as cloth is usually in fixed sizes.&lt;/p&gt;

&lt;p&gt;Note that flags are physically made of thread, we make the simplifying assumption that all flags are made of the same width thread, and that the thread is evenly spaced.&lt;/p&gt;

&lt;p&gt;Flags have some terminology, so a few definitions are in order:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hoist&lt;/strong&gt; is the width of the flag (vertical direction)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fly&lt;/strong&gt; is the length of the flag (horizontal direction)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vexillology&lt;/strong&gt; is the &amp;ldquo;scientific study of the history, symbolism and usage of flags &lt;a href=&#34;http://en.wikipedia.org/wiki/Vexillology&#34;&gt;[1]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will call &lt;strong&gt;H&lt;/strong&gt; the number of threads in the vertical direction, and &lt;strong&gt;F&lt;/strong&gt; the number of threads in the horizontal direction.&lt;/p&gt;

&lt;p&gt;Assuming threads are evenly spaced, we can imagine the &lt;strong&gt;H*F&lt;/strong&gt; crossing points on a grid, as in the image below:&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/flags/close_up.png %}&lt;/p&gt;

&lt;p&gt;Each crossing point is either above or below, so there are 2 distinct choices for each of the &lt;strong&gt;H*F&lt;/strong&gt; crossing points, that means that there are 2&lt;sup&gt;&lt;sup&gt;HF&lt;/sup&gt;&lt;/sup&gt; possible flags, ignoring color.&lt;/p&gt;

&lt;p&gt;If we now consider the role of color, imagine that each of the &lt;strong&gt;H+F&lt;/strong&gt; threads could have any of &lt;strong&gt;C&lt;/strong&gt; distinct colors, then there would be C&lt;sup&gt;&lt;sup&gt;(H+F)&lt;/sup&gt;&lt;/sup&gt; possible color combinations.&lt;/p&gt;

&lt;p&gt;Since the under/over configuration of the points is independent from the color choices, it follows from the combinatorial principle of products that there are:&lt;/p&gt;

&lt;p&gt;{% latex %}
$ 2^{HF}C^{(H+F)} $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;possible flags. This is the general solution, now let&amp;rsquo;s find some real-world data and get some more constraints so we can compute some numbers. (*Everything following this formula is just finding the values of &lt;strong&gt;H&lt;/strong&gt; and &lt;strong&gt;F&lt;/strong&gt;, so if you don&amp;rsquo;t care about the research, simplifying assumptions and data-wrangling, you can skip to the end*)&lt;/p&gt;

&lt;p&gt;Typically there are fixed aspect ratios, and some correlation exists between the height of the flagpole and the hoist/fly.&lt;/p&gt;

&lt;h2 id=&#34;height-of-the-flagpole-versus-the-fly-and-hoist&#34;&gt;Height of the flagpole versus the fly and hoist&lt;/h2&gt;

&lt;p&gt;Using the United States&amp;rsquo; Deparment of Interior specifications as a model, we can use the following data to get an approximate relation between the height of a ground flag and the hoist/fly of the flag:&lt;/p&gt;

&lt;p&gt;Ground Flagpoles &lt;a href=&#34;http://www.doi.gov/ofas/asd/upload/Flagsandseals9-25-12-2.pdf&#34;&gt;[2]&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;height (ft)  hoist (ft)    fly (ft)   aspect ratio (hoist/fly)
30           3.5           6.65       1.9
40           5.0           9.5        1.9
50           5.0           9.5        1.9
60           8.95          17         1.89
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the aspect ratio is approximately constant (as we would expect), the problem of finding the relation between height, hoist and fly reduces to a one-dimensional linear regression. We now try to find fly as a function of height, which is in the &lt;strong&gt;y&lt;/strong&gt; direction:&lt;/p&gt;

&lt;p&gt;{% latex %}
$ f(y) = a + by $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;Using the &lt;a href=&#34;http://en.wikipedia.org/wiki/Least_squares&#34;&gt;least squares method&lt;/a&gt;, the values of a and b are found exactly, the above formula becomes:&lt;/p&gt;

&lt;p&gt;{% latex %}
$ f(y) = 0.3105y + (-3.31) $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;So given a height &lt;strong&gt;y&lt;/strong&gt;, the fly of the flag should be about &lt;strong&gt;(0.31)y - 3.31(ft)&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;aspect-ratios&#34;&gt;Aspect ratios&lt;/h2&gt;

&lt;p&gt;To find the aspect ratios of the current flags of Earth, I found &lt;a href=&#34;https://en.wikipedia.org/wiki/User:SiBr4/List_of_national_flags_by_aspect_ratio&#34;&gt;this&lt;/a&gt; on wikipedia. I went to the edit view and then copied the wiki source. On Mac OS X, the &lt;code&gt;pbpaste&lt;/code&gt; command writes the contents of the clipboard to standard out on the command line. On GNU/Linux under Xorg, you can use &lt;code&gt;xclip -o&lt;/code&gt; to achieve the same thing.&lt;/p&gt;

&lt;p&gt;So I played around with the data and came up with this one-liner:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; pbpaste | pre nts | awk -F\| &#39;{print $3}&#39; | sed &#39;s/[\}]//g&#39; | pcregrep &#39;^\d&#39; | sort -n | uniq -c
   1 0.820
   2 1
   1 1.154
   1 1.167
   1 1.25
   1 1.321
   5 1.333
   3 1.375
   1 1.389
   2 1.4
   2 1.429
   1 1.467
 114 1.5
   1 1.571
   5 1.6
   1 1.618
   1 1.636
  22 1.667
   2 1.75
   1 1.772
   1 1.864
   4 1.9
  83 2
   1 2.545
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most countries use 1.5, 2 and 1.667. As fractions, these are &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;, &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;, &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;, respectively. Also, one country (Togo in Africa) uses 1.618 &amp;#8776; &amp;phi;, the Golden Ratio!&lt;/p&gt;

&lt;p&gt;Since the overwhelming majority of flags use the 1.5 and 2 ratios, let us assume for this problem that these are the only ratios that will be used. Since the United States flag uses the 1.9 ratio, we can approximate it as 2. Just for reference, Russia and China use 1.5 and U.S.A. uses 1.9, and the U.K. uses 2.&lt;/p&gt;

&lt;p&gt;Colonizers on other planets will initially be close to the ground and spread out. Since residential flags typically range between 15 and 20 feet, we will be safe and assume that the inital flag is 15 feet tall. From our formula, this means that the Fly will be (.3)(15ft) - (3.31ft) = 1.19 ft.&lt;/p&gt;

&lt;h2 id=&#34;number-of-threads&#34;&gt;Number of threads&lt;/h2&gt;

&lt;p&gt;To find the values of &lt;strong&gt;H&lt;/strong&gt; and &lt;strong&gt;F&lt;/strong&gt;, we need to know the width and spacing of the thread, a common size of polyester thread for making flags is &lt;a href=&#34;http://www.thethreadexchange.com/miva/merchant.mvc?Screen=CTGY&amp;amp;Category_Code=nylon-thread-069&#34;&gt;Size 69&lt;/a&gt;, which has a diameter of 0.2921 mm. So, assuming that the threads are all adjacent, the number of threads in the Fly direction will be (1.19ft)/(0.2921 mm) &amp;#8776; 1241.&lt;/p&gt;

&lt;p&gt;The number of threads in the Hoist direction (assuming a ratio of 1.5) is 1241*(1.5) &amp;#8776; 1861&lt;/p&gt;

&lt;h2 id=&#34;number-of-colors-distinguishable-by-the-human-eye&#34;&gt;Number of Colors Distinguishable by the Human Eye&lt;/h2&gt;

&lt;p&gt;This number is about 10,000,000 &lt;a href=&#34;http://hypertextbook.com/facts/2006/JenniferLeong.shtml&#34;&gt;[4]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;**The number of distinct, 15 foot, &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; flags made of size 69 polyester thread is **&lt;/p&gt;

&lt;p&gt;{% latex %}
$ 2^{1861\times1241}(10,000,000)^{1861+1241} \approx 1.19 \times 10^{716943} $
{% endlatex %}&lt;/p&gt;

&lt;p&gt;This is a 716,944 digit number, the number of possible flags is so much higher than &lt;a href=&#34;http://www.wolframalpha.com/input/?i=number+of+particles+in+the+universe&#34;&gt;the number of atoms in the observable Universe&lt;/a&gt; that it isn&amp;rsquo;t even plausible to assume that all of them could ever be exhausted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reinventing the wheel: Or how I learned to stop coding and read the manpages</title>
      <link>/blog/2013/01/28/reinventing-the-wheel-or-how-i-learned-to-stop-coding-and-read-the-manpages/</link>
      <pubDate>Mon, 28 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>/blog/2013/01/28/reinventing-the-wheel-or-how-i-learned-to-stop-coding-and-read-the-manpages/</guid>
      <description>&lt;p&gt;About a month ago I &lt;a href=&#34;/blog/2012/12/30/building-command-line-utilities-in-ruby-that-play-well-with-the-rest-of-the-unix-utilities/&#34;&gt;wrote about a command line utility&lt;/a&gt; I made that calculates word and character frequencies. It was packaged as a ruby gem and it interacted well with the Unix pipeline interface.&lt;/p&gt;

&lt;p&gt;Then, about 2 or 3 weeks later, I come across this post on Twitter:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p&gt;Show how many times each line in a sorted file is repeated: uniq -c&lt;/p&gt;&amp;mdash; Unix tool tip (@UnixToolTip) &lt;a href=&#34;https://twitter.com/UnixToolTip/status/292295351518498816&#34;&gt;January 18, 2013&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;And I realized that I could construct a one-liner that does what my gem did. Probably faster too. I know about uniq and sort, and I&amp;rsquo;ve used awk a little bit, but am not really familiar with most of it&amp;rsquo;s capabilities.&lt;/p&gt;

&lt;p&gt;The two features I implemented in ruby were (1) counting word frequencies and (2) counting character frequencies. I defaulted everything to lower case and stripped out non-alphanumeric characters.&lt;/p&gt;

&lt;p&gt;Using @UnixToolTip&amp;rsquo;s suggestion of &lt;code&gt;uniq -c&lt;/code&gt;, I came up with this alternative:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for word in $(cat filename); do echo $word; done | sed &#39;s/[^a-zA-Z0-9]//g&#39; | tr &#39;[A-Z]&#39; &#39;[a-z]&#39; | sort | uniq -c | sort -nr | head
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This just outputs the file, splits everything up by whitespace, strips out anything that isn&amp;rsquo;t alphanumeric, then lowercases, sorts, and counts the number of repetitions using &lt;code&gt;uniq -c&lt;/code&gt;. The result of that is then sorted numerically, to get the most frequent items at the top of the output, and then displays just the top 10 lines using &lt;code&gt;head&lt;/code&gt;. There are some small numerical differences between this and my gem, and that is most likely because I split by word boundary in ruby, but split by whitespace on the bash one-liner.&lt;/p&gt;

&lt;p&gt;For the problem I was trying to solve, I could have saved some time by digging through the manpages instead of writing another gem. I did enjoy working with the Rubygems packaging system, but I am starting to think that was overkill.&lt;/p&gt;

&lt;p&gt;NOTE: For the character count feature, all I have to do is output one character per line, then I can insert that into the pipeline to get the desired output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(CONTENTS OF FILENAME, 1 CHARACTER PER LINE) | sed &#39;s/[^a-zA-Z0-9]//g&#39; | tr &#39;[A-Z]&#39; &#39;[a-z]&#39; | sort | uniq -c | sort -nr | head
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m not sure how to do this at the moment, I think &lt;code&gt;awk&lt;/code&gt; can do it pretty simply, I&amp;rsquo;ll read the manpages, but for now I have to get to work.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building command line utilities in Ruby that play well with Unix</title>
      <link>/blog/2012/12/30/building-command-line-utilities-in-ruby-that-play-well-with-the-rest-of-the-unix-utilities/</link>
      <pubDate>Sun, 30 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/12/30/building-command-line-utilities-in-ruby-that-play-well-with-the-rest-of-the-unix-utilities/</guid>
      <description>

&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Pipeline_%28Unix%29&#34;&gt;Unix pipeline&lt;/a&gt; is a beautiful thing, as long as Standard Input and Standard Output are handled correctly, programs can be kept small and predictable. Getting any sort of complex functionality is simply a matter of composing the appropriate command line utilties via the Unix pipeline.&lt;/p&gt;

&lt;p&gt;When taking &lt;a href=&#34;https://www.coursera.org/course/crypto&#34;&gt;Coursera&amp;rsquo;s Cryptography I class&lt;/a&gt;, I learned about how all substitution ciphers could be cracked using character frequency analysis. Basically, in English plaintext, there is a very non-uniform distribution over the alphabet, as you can see here:&lt;/p&gt;

&lt;p&gt;{% img &lt;a href=&#34;http://upload.wikimedia.org/wikipedia/commons/b/b0/English_letter_frequency_%28frequency%29.svg&#34;&gt;http://upload.wikimedia.org/wikipedia/commons/b/b0/English_letter_frequency_%28frequency%29.svg&lt;/a&gt; r%}&lt;/p&gt;

&lt;p&gt;Using this, no matter how you scramble up the alphabet, given enough ciphertext, you can use this distribution to figure out how the alphabet was scrambled.&lt;/p&gt;

&lt;p&gt;As I learned this, I wanted to test it on real data sets like Sherlock Holmes and Beowulf. There was a lot of English text, so I looked around for a command line utility that counted character or word frequency. I couldn&amp;rsquo;t find one, so I whipped together a ruby program.&lt;/p&gt;

&lt;p&gt;Aside from substitution ciphers, I like knowing word and character frequencies for other reasons, and I was a bit annoyed that such a thing didn&amp;rsquo;t exist, so I made one. Since I&amp;rsquo;ve been doing Ruby development for about a year, I thought it was about time to learn how ruby gems are born.&lt;/p&gt;

&lt;p&gt;Buildling a gem is very easy, one just has to run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; bundle gem foo
      create  foo/Gemfile
      create  foo/Rakefile
      create  foo/LICENSE.txt
      create  foo/README.md
      create  foo/.gitignore
      create  foo/foo.gemspec
      create  foo/lib/foo.rb
      create  foo/lib/foo/version.rb
Initializating git repo in /Users/tobi/foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, cd into the &lt;code&gt;foo&lt;/code&gt; directory, hack away on the code, and then do a &lt;code&gt;rake release&lt;/code&gt;, which publishes to rubygems.org. Then, anyone else can just run &lt;code&gt;gem install foo&lt;/code&gt; and start using your program.&lt;/p&gt;

&lt;p&gt;I wrote a gem called wordfreq that computed the word or character frequencies (if the -c flag was given), this was a quick way to verify the distribution above for the alphabet.&lt;/p&gt;

&lt;p&gt;The thing I got hung up on was the Errno::EPIPE exception in Ruby. When I wrote wordfreq and then piped its output to &lt;code&gt;head&lt;/code&gt;, the Errno::EPIPE exception was thrown. I thought I was doing something wrong, but it turned out that I just needed to handle that exception, since utilities like &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; stop reading after 10 lines. When &lt;code&gt;head&lt;/code&gt; or &lt;code&gt;tail&lt;/code&gt; stops reading, Ruby throws an Errno::EPIPE exception. The way I solved the problem was to handle the Errno::EPIPE exception by breaking out of the main loop.&lt;/p&gt;

&lt;p&gt;Here is the github repository with the source code and documentation: &lt;a href=&#34;https://github.com/tlehman/wordfreq&#34;&gt;https://github.com/tlehman/wordfreq&lt;/a&gt;, or if you want to start using it, just run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install wordfreq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Publishing gems is very easy with Bundler, and it is a great way to make small command line utilities. But make sure you respond appropriately when pipes close, that way your command lime tool will mesh nicely with the rest of the Unix tools.&lt;/p&gt;

&lt;h2 id=&#34;further-reading&#34;&gt;Further Reading:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://jstorimer.com/2011/12/12/writing-ruby-scripts-that-respect-pipelines.html&#34;&gt;Writing Ruby Scripts That Respect Pipelines (J. Storimer)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ibm.com/developerworks/aix/library/au-spunix_pipeviewer/&#34;&gt;Speaking Unix: Peering into Pipes (M. Streicher)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fixing spaces in filenames</title>
      <link>/blog/2012/11/19/fixing-spaces-in-filenames/</link>
      <pubDate>Mon, 19 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/11/19/fixing-spaces-in-filenames/</guid>
      <description>&lt;p&gt;Sorry this has taken so long, I&amp;rsquo;ve been working on the &lt;a href=&#34;https://www.coursera.org/course/crypto&#34;&gt;Cryptography Coursera class&lt;/a&gt;,
to get rid of all spaces in all files below the current directory, the following bash script will do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for filename in $(find .); do
  newfilename=$(echo $filename | sed &#39;s/ /_/g&#39;); 
  mv $filename $newfilename
done
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Spaces in filenames</title>
      <link>/blog/2012/10/29/spaces-in-filenames/</link>
      <pubDate>Mon, 29 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/10/29/spaces-in-filenames/</guid>
      <description>&lt;p&gt;I don&amp;rsquo;t like spaces in filenames. This trend started when I started playing with the command line on Linux
back when I was about 13. Working with the shell, each space had to be escaped, which is just enough of an
annoyance to warrant avoiding spaces altogether as a basic principle.&lt;/p&gt;

&lt;p&gt;I got to thinking about this recently when I tried to find out how I could get rid of the space in the name
of my Google Drive directory. I use both Dropbox and Google Drive, and as a package, I prefer Dropbox because
of their out-of-the-box Linux support. However, Google Drive allows for a smaller per-month charge, and at the
time of this post, the cost per byte is about the same between the two. Also, when you install Dropbox, you
don&amp;rsquo;t have a stupid space in the middle of the directory name!&lt;/p&gt;

&lt;p&gt;Out of curiosity, I did a little experiment to find out how steadfastly I had been applying my own principle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~ &amp;gt; find Dropbox | wc -l
    9909
~ &amp;gt; find Dropbox | grep &amp;quot; &amp;quot; | wc -l
     834
~ &amp;gt; python -c &amp;quot;print(834.0/9909.0)&amp;quot;
0.084165909779
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, 8.4% of my file and directory names have spaces in them. Apparently, my four years of dropbox usage have
been rather unprincipled.&lt;/p&gt;

&lt;p&gt;Performing the same experiment on the Google Drive directory requires an extra step, since &amp;ldquo;Google Drive&amp;rdquo; is
the name of the root directory, I had to shave off that part using sed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;~ &amp;gt; find Google\ Drive | sed &#39;s/Google Drive\///g&#39; | wc -l
    2263
~ &amp;gt; find Google\ Drive | sed &#39;s/Google Drive\///g&#39; | grep &amp;quot; &amp;quot; | wc -l
      68
~ &amp;gt; python -c &amp;quot;print(68.0/2263.0)&amp;quot;
0.0300486080424
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, correcting for the root directory&amp;rsquo;s name, only 3% of the stuff in my Google Drive have spaces in the name.&lt;/p&gt;

&lt;p&gt;In practice, I only follow this principle about 92-97% of the time, I can improve on that with a simple script,
once I have it made, I&amp;rsquo;ll post it for others who agree about how files should be named.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unix Processes and Their Parents Part 2</title>
      <link>/blog/2012/10/28/unix-processes-and-their-parents-part-2/</link>
      <pubDate>Sun, 28 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/10/28/unix-processes-and-their-parents-part-2/</guid>
      <description>&lt;p&gt;Based on a comment by Mark Essel from &lt;a href=&#34;/blog/2012/10/14/unix-processes-and-their-parents/&#34;&gt;part 1&lt;/a&gt; I have been trying
to add more metadata to the process tree. I have given up on doing it in a one-liner, so I started using bash scripts.&lt;/p&gt;

&lt;p&gt;Then, after a few hours of hacking bash, I got annoyed with the difficulty of very basic things such as incrementing
integers and dealing with collections, so I switched over to Ruby, with some minor shelling out.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href=&#34;https://github.com/tlehman/procviz&#34;&gt;procviz&lt;/a&gt;, it is some ruby code for generating a graph representing
the process tree at the time &lt;code&gt;Graph.new&lt;/code&gt; is called.&lt;/p&gt;

&lt;p&gt;It generates DOT files just fine, but the images can get big if your system has a lot of stuff running. Also, the only
metadata I have attached to the nodes so far is the command name:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/images/blogimg/proc_with_names.png&#34;&gt;
  &lt;img src=&#34;/images/blogimg/proc_with_names.png&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I wanted to make this into a more interactive visualization, but so far I have had a hard time getting Sigma.js or Arbor.js
to embed into this Octopress blog. I have been meaning to get a better understanding of javascript.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Visualizing Unix processes and their parents</title>
      <link>/blog/2012/10/14/unix-processes-and-their-parents/</link>
      <pubDate>Sun, 14 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/10/14/unix-processes-and-their-parents/</guid>
      <description>&lt;p&gt;I am reading Jesse Storimer&amp;rsquo;s fantastic little book &lt;a href=&#34;http://workingwithunixprocesses.com/&#34;&gt;&amp;ldquo;Working with Unix Processes&amp;rdquo;&lt;/a&gt; right now, and inspiration struck after the second chapter &amp;ldquo;Processes Have Parents&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;When a Unix process is born, it is a literal copy of it&amp;rsquo;s parent process. For example, if I am typing &lt;em&gt;ls&lt;/em&gt; into a bash prompt, the bash process spawns a copy of itself using the &lt;em&gt;fork&lt;/em&gt; system call. The parent process (bash) has an id which is associated with the child process (ls). Using the Unix &lt;em&gt;ps&lt;/em&gt; command, you can see the parent process id of every process on the system.&lt;/p&gt;

&lt;p&gt;The only process that has no parent is &lt;em&gt;sched&lt;/em&gt;, it has process id zero. The idea I had was to make a visualization of this branching tree of Unix processes. I am currently running Debian GNU/Linux, a Unix-like operating system. I came up with this one-liner that shows the (parent id -&amp;gt; child id) relation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot; | grep -v &amp;quot;PID&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first part calls &lt;em&gt;ps&lt;/em&gt; and gets all process ids, and their parents. Some sample output is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ &amp;gt; ps axo ppid,pid
 PPID   PID
    0     1
    0     2
    2     3
    2     6
    2     7
    2     8
    2    10
    2    12
    2    13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This output is piped into &lt;em&gt;sed&lt;/em&gt; (*s*tream *ed*itor), and the empty space between the numbers is replaced with an arrow &amp;ldquo;-&amp;gt;&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ &amp;gt; ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot;
 PPID -&amp;gt;   PID
    0 -&amp;gt;     1
    0 -&amp;gt;     2
    2 -&amp;gt;     3
    2 -&amp;gt;     6
    2 -&amp;gt;     7
    2 -&amp;gt;     8
    2 -&amp;gt;    10
    2 -&amp;gt;    12
    2 -&amp;gt;    13
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PPID is Parent Process Id, and PID is just Process Id. Finally, I use &lt;em&gt;grep -v &amp;ldquo;PID&amp;rdquo;&lt;/em&gt; to let all the lines through that don&amp;rsquo;t contain &amp;ldquo;PID&amp;rdquo;. This selects those lines that are actual process relations.&lt;/p&gt;

&lt;p&gt;In this case, it just chops off the first line. Next, I wanted to convert this into a file that I can feed into &lt;a href=&#34;http://www.graphviz.org/&#34;&gt;GraphViz&lt;/a&gt;, an open source graph visualization tool. The format is pretty simple, an example is in order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;digraph Foo {
  1 -&amp;gt; 2
  1 -&amp;gt; 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above file defines a graph called &amp;ldquo;Foo&amp;rdquo; that has three nodes and two edges, it looks like this:&lt;/p&gt;

&lt;p&gt;{% img /images/blogimg/Foo.png %}&lt;/p&gt;

&lt;p&gt;Now, all we have to do to the PPID-&amp;gt;PID output above is to wrap it in braces and prepend two words to the beginning.&lt;/p&gt;

&lt;p&gt;We can use &lt;em&gt;echo &amp;ldquo;digraph proc { SOME COMMAND }&amp;rdquo;&lt;/em&gt; to wrap the output of our command, then dump the results in a file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &amp;quot;digraph proc { `ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot; | grep -v &amp;quot;PID&amp;quot;` } &amp;quot; &amp;gt;&amp;gt; proc.dot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, GraphViz has several commands for rendering graphs in various ways. The first thing I tried was a symmetric layout, but that produced a hierarchical, &lt;em&gt;very wide&lt;/em&gt; image. So I tryed &lt;em&gt;circo&lt;/em&gt; which produces a radial layout:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;~ &amp;gt; echo &amp;quot;digraph proc { `ps axo ppid,pid | sed &amp;quot;s/\b / -&amp;gt; /g&amp;quot; | grep -v &amp;quot;PID&amp;quot;` } &amp;quot; &amp;gt;&amp;gt; proc.dot
~ &amp;gt; circo proc.dot -Tpng &amp;gt;&amp;gt; radial_proc.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the radial layout:
{% img /images/blogimg/radial_proc.png %}&lt;/p&gt;

&lt;p&gt;You can see the original ancestor of all processes, &lt;em&gt;sched&lt;/em&gt; with PID 0 right in the center, then PID 1 which is called &lt;em&gt;init&lt;/em&gt; has a bunch of children. I am writing this post in vim in a bash shell in a gnome terminal emulator, the vim PID is 14819, but it is hard to see in this image, there is too much overlap.&lt;/p&gt;

&lt;p&gt;Fortunately, we can modify the proc.dot file and include &lt;em&gt;overlap=false&lt;/em&gt; right above the PPID-&amp;gt;PID pairs. Also, I found from the man pages for the graphviz tools that the &lt;em&gt;splines=true&lt;/em&gt; option will draw the edges as splines (curves) instead of straight lines. Also, instead of using &lt;em&gt;circo&lt;/em&gt;, there is another tool called &lt;em&gt;neato&lt;/em&gt; that will render a more symmetrical graph than circo.&lt;/p&gt;

&lt;p&gt;This rendering took &lt;em&gt;much&lt;/em&gt; longer than circo rendering, but is much nicer (click to enlarge):&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/images/blogimg/sym_proc.png&#34;&gt;
  &lt;img src=&#34;/images/blogimg/sym_proc.png&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I remember learning in my C programming class that Unix processes all had to be made with fork. It reminded me of asexual reproduction where two identical copies are made. I look forward to learning more about the Unix process model, and recommend Jesse&amp;rsquo;s book.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Avoiding a catch-22</title>
      <link>/blog/2012/08/18/avoiding-a-catch-22/</link>
      <pubDate>Sat, 18 Aug 2012 00:00:00 +0000</pubDate>
      
      <guid>/blog/2012/08/18/avoiding-a-catch-22/</guid>
      <description>&lt;p&gt;I recently needed to find out if I had a particular version of the .NET
Framework installed. I googled around and found the registry key that
has this information.&lt;/p&gt;

&lt;p&gt;Then, like a moron, I decided to write a C# program that would return
this information, and I wrapped it in a cmdlet so I could run it from
the powershell. I made my first powershell cmdlet,
&lt;a href=&#34;https://github.com/tlehman/get-dotnet-versions&#34;&gt;get-dotnet-versions&lt;/a&gt;.
 All it does is fetch the subkeys of &lt;em&gt;HKLM\SOFTWARE\Microsoft\NET
Framework Setup\NDP&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;So, in order to find which versions of .NET I had installed, I compiled
the C# source code, and this process used .NET libraries. So, which
version of .NET do I target the assembly? Well, let&amp;rsquo;s see which versions
I have installed? Catch-22.&lt;/p&gt;

&lt;p&gt;To avoid this, I googled around some more and found the &lt;del&gt;crusty&lt;/del&gt; trusty old reg.exe, I
can query the windows registry with the simple command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bat&#34;&gt;reg query &amp;quot;HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The benefit of this is that I avoid that catch-22. Sometimes all that
infrastructure gets in the way.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>