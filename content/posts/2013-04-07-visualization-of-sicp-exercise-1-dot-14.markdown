---
categories:
- graphviz
- data-visualization
- sicp
- lisp
- scheme
- programming
comments: true
date: 2013-04-07T00:00:00Z
title: Visualization of SICP Exercise 1.14
url: /blog/2013/04/07/visualization-of-sicp-exercise-1-dot-14/
---

I am currently working my way the [Structure and Interpretation of
Computer Programs](https://github.com/tlehman/sicp-exercises#readme)
and I've skipped past exercise 1.14, and come back to it after a bit
of thinking, here's the problem, and then the exercise.

## The Problem

How many ways are there to make change of a given amount `a` with the
following kinds of coins?

 - pennies
 - nickels
 - dimes
 - quarters
 - half-dollars

There is a recursive solution to this combinatorial problem, which can
readily be made into executable code in Scheme, this kind of solution
is very standard in enumerative combinatorics:

The number of ways to change amount `a` using `n` kinds of coins
equals:

 - the number of ways to change amount `a` using all but the first
 kind of coin, plus
 - the number of ways to change amount `a - d` using all `n` kinds of
 coins, where `d` is the denomination of the first kind of coin

Note that those two items are mutually exclusive and exhaustive
conditions, so the result can be calculated by simply adding the two
values.

In scheme, the above list could be transliterated as:

```scheme
	(+ (cc a (- n 1))
	   (cc (- a d) n))
```

Where `(cc a n)` computes the number of ways of changing amount `a` with `n`
kinds of coins.

The full code for the `count-change` procedure can be found
[here](https://github.com/tlehman/sicp-exercises/blob/master/count-change.scm#L3).

## The Exercise

With the `count-change` procedure at hand, Exercise 1.14 is to "draw
the tree illustrating the process generated by the `count-change`
procedure in making change for 11 cents."

## The Solution

The `count-change` procedure uses the `(cc a n)` procedure where
`n = 5`, and the `cc` procedure naturally gives rise to a binary
tree that locally looks like this:

{% img /images/blogimg/ccan.png %}

I prefer to make the computer go through all the steps and produce an
image for me, so I took a break on 1.14 and thought about it for a
while.

To represent the tree, I used the graph-description language
[DOT](http://www.graphviz.org/pub/scm/graphviz2/doc/info/lang.html)

To generate the tree, I started by adding a print statement around the
recursion steps, the problem with that is that there can be distinct
nodes that happen to have the same argument values, that is, the node
in the tree may be labeled `(cc a n)`, but there may also be multiple
nodes with the same `a` and `n` values. To avoid this, each node must
be given a unique id, and then be displayed with the `(cc a n)` label.

One way to label a binary tree's nodes is to make the id be a map of
the location of the node in the tree. For example, if a node of the
tree has id `x`, then the root's children will be `xl` and `xr`,
respectively, where `l` stands for 'left' and `r` stands for 'right'.

If the root's id is `s`, then a typical node would be labeled
something like `sllrrl`. Starting at the root, you can find the node
by going left two times, right two times, and then left.

Here is the full source of the tree-generating code `cc-graph`:

<a name="quasiquote">
```scheme

(define (cc-graph amount kinds-of-coins)

  (define display-node (lambda (label amount kinds-of-coins)
                         (begin
                           (display "  ")
                           (display label)
                           (display " [label=\"")
                           (display `(cc ,amount ,kinds-of-coins))
                           (display "\"];")
                           (newline))))

  (define display-edge (lambda (a b)
                         (begin
                           (display "  ")
                           (display a)
                           (display " -> ")
                           (display b)
                           (display ";")
                           (newline))))

  (define base-case (lambda (amount kinds-of-coins)
                      (or (< amount 0)
                          (= kinds-of-coins 0)
                          (= amount 0))))

  (define left (lambda (label)
                  (string-append label "l")))

  (define right (lambda (label)
                  (string-append label "r")))


  ; label is the unique label of the function invocation
  (define (recurse label amount kinds-of-coins)
    (if (base-case amount kinds-of-coins)
        (display-node label amount kinds-of-coins)
        (begin
          (display-node label amount kinds-of-coins)
          (display-edge label (left label))
          (display-edge label (right label))
          (recurse (left label) amount (- kinds-of-coins 1))
          (recurse (right label)
                   (- amount (first-denomination kinds-of-coins))
                   kinds-of-coins))))

  (begin
    (display "digraph {")
    (newline)
    (recurse "s" amount kinds-of-coins)
    (newline)
    (display "}")))

```
</a>

Finally, the output of running `(cc-graph 11 5)`, then piping the
results into GraphViz gives the desired tree:

{% img /images/blogimg/cc_11_5.png %}

I love this way of visualizing recursion, you can see how the problem
is reduced into simpler sub-problems, and that there is a distinct
'shape' to the computation.

There are more than 100 edges in that tree, I would not have wanted to
do that by hand, all for a measley value of four.

The final value of `(cc 11 5)` is 4, that is, there are 4 ways of
making change for 11 cents. Unfortunately, this solution doesn't say
what exact combinations of coins, only that there are four.

Just thinking about it, you can make 11 cents with

 - 11 pennies
 - 6 pennies, 1 nickel
 - 1 penny, 2 nickels
 - 1 penny, 1 dime

I would like to generalize `cc-graph` so that I can get a
visualization of any recursive function in Scheme, this will take more
knowledge of the language and it's introspective features, stay tuned!
